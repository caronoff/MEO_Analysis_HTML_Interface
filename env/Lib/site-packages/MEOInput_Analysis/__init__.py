import logging
import os

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s %(message)s',
                    filename= os.path.dirname(os.path.abspath(__file__)) + "MEOimportlog.txt",
                    filemode='w')
import numpy as np
import pandas as pd
from itertools import repeat
logging.info('numpy pandas and itertools')
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.dates import DayLocator, HourLocator, DateFormatter, MinuteLocator, drange
from matplotlib.backends.backend_pdf import PdfPages
logging.info('imported matplotlib')
import math
import sys
import os
import xlrd
logging.info('imported math, sys, os and xlrd')
from datetime import datetime, timedelta
import csv
logging.info('datetime and csv')
from collections import OrderedDict, defaultdict
import simplekml
logging.info('collections and simplekml')
import re
import beacon_decode as bcn
logging.info('re and beacon decode')
import pypyodbc
logging.info('pypyodbc imported - all modules imported')
from polycircles import polycircles
from decimal import *

getcontext().prec = 3

#kml = simplekml.Kml()
UID = 'jesse'
PWD = 'nopw'

pd.options.mode.chained_assignment = None # turn off SettingWithCopyWarning

# Set global values

MEOLUTName ={3669:'Florida',3385:'Hawaii',3677:'Maryland'}
MEOList = [3669, 3385, 3677]
MEORefLoc = {3669:(25.6162, -80.3843),3385:(21.52071, -157.9963), #Reference Beacon Locations
    3677:(38.999121, -76.853789)} # Goddard beacon antenna unknown

MEOLUTLoc = {3669:(25.617645, -80.383211), 3385:(21.5244, -158.0012), #MEOLUT Locations
    3677:(38.999121, -76.853789)}

sat_list = [302, 315, 324, 430, 329, 408, 422, 319, 306, 317, 422, 430]
''' see http://www.cospas-sarsat.int/en/system/space-segment-status-pro/current-space-segment-status-and-sar-payloads-pro  for full list '''
all_sarsats = [401, 402, 403, 404, 405, 407, 408, 409, 414, 418, 419, 420, 422, 
               424, 426, 430, 501, 502, 301, 302, 303, 306, 308, 309, 310, 312, 
               315, 316, 317, 318, 319, 323, 324, 326, 327, 329, 330, 332]
us_sarsats = allsats = [408, 409, 419, 422, 424, 426, 430, 301, 302, 303, 306, 
                        308, 309, 310, 312, 315, 316, 317, 318, 319, 323, 324, 
                        326, 327, 329, 330, 332]

def haversine(x):
    """
    Calculate the great circle distance between two points 
    on the earth (specified in decimal degrees)
    """
    # convert decimal degrees to radians 
    for i in x:
        #print 'i = '
        #print type(i)
        #print i
        if i == None:
            #print i
            #print 'N/A'
            return None

    lat1, lon1, lat2, lon2 = map(np.radians, [x[0], x[1], x[2], x[3]])
    # haversine formula 
    dlon = lon2 - lon1 
    dlat = lat2 - lat1 
    a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
    c = 2 * np.arcsin(np.sqrt(a)) 
    r = 6373 # Radius of earth in kilometers. Use 3956 for miles
    #print c*r         
    return c * r

#safe division (don't fail for divide by 0, return 0) 
def safe_div(a,b):
    if b<=0:
        return 0
    else: return a/float(b)

#Write function that filters data based on one field (filter field, filter criteria) 
def filter1(df, field, criteria):
    return df[df[field]==float(criteria)]

#Write function that filters data based on range of one field (filter field, filter criteria_low, filter criteria_high) 
def filter_range(df, field, criteria_low, criteria_high):
    return df[((df[field] >= float(criteria_low)) & (df[field] <= float(criteria_high)))]

def singleburst_loc(df, lat_GT, lon_GT, MEOLUT):
    df2 = df[(df.sourceid == MEOLUT)]
    if df2.empty: return df2

    df2['Lat_GT'],df2['Lon_GT'] = lat_GT, lon_GT
    df2['Error_GT'] = df2[['latitude','longitude', 'Lat_GT','Lon_GT']].apply(haversine, axis = 1)
    df2['Error_Enc'] = df2[['latitude','longitude','Enc_Lat','Enc_Lon']].apply(haversine, axis = 1)
    dfSB = df2.sort_values('timelast')
    dfSB = dfSB.drop(['Lat_GT','Lon_GT'],axis = 1)
    dfSB['timestart_diff'] = dfSB['timefirst'].shift(-1) - dfSB['timefirst']
    dfSB['TimeToMcc'] = dfSB.index - dfSB['timelast']
    dfSB['TimeToGenerate'] = dfSB.index - dfSB['timelast']
    dfSB = dfSB[(dfSB.timestart_diff > pd.Timedelta(seconds = 5)) | (dfSB.timestart_diff.isnull())] ###PROBLEM
    return dfSB

def multiburst_loc(df,lat_GT,lon_GT,MEOLUT, window_span):
    timefirst = df.timefirst.min()
    timelast = df.timelast.max()
    df2 = df[(df.sourceid == MEOLUT)]
    if df2.empty: return df2
    df2['Lat_GT'],df2['Lon_GT'] = lat_GT, lon_GT
    df2['Error_GT'] = df2[['latitude','longitude', 'Lat_GT','Lon_GT']].apply(haversine, axis = 1)
    df2['Error_Enc'] = df2[['latitude','longitude','Enc_Lat','Enc_Lon']].apply(haversine, axis = 1)

    ##df2 = df2.sort_values('TimeFirst')
    df3 = df2.drop(['Lat_GT','Lon_GT'],axis = 1)
    
    # Sorting and finding windows
    df3 = df3.sort_values('timelast') #Rethink how you do windows 12/9 -- I think it was solved previously 1/8/17
    df3['timestart_diff'] = df3['timefirst'].shift(-1) - df3['timefirst']
    df3['timestart_diff2'] = df3['timefirst'].shift(-2) - df3['timefirst']
    df3['TimeToMcc'] = df3.index - df3['timelast']
    df3['TimeToGenerate'] = df3.index - df3['timelast']
    #print df3.iloc[180:240,:]
    df3['last_in_window'] = (df3.timestart_diff > pd.Timedelta(minutes = 9)) & (df3.timestart_diff2 > pd.Timedelta(minutes = 3))    
    #print df3[['TimeFirst','timestart_diff','timestart_diff2','last_in_window']]
    df3 = df3[((df3.timestart_diff > pd.Timedelta(minutes = 9)) & (df3.timestart_diff2 > pd.Timedelta(minutes = 3))) | df3.timestart_diff.isnull()] 
    return df3  

def find_packets(servername= 'localhost', databasename='MccTestLGM', beaconid = '%', start_date = 0, end_date = None, MEOLUT = '%',ant_i = '%', sat = '%', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server}; Server='+servername+'; Database='+databasename+'; Trusted_Connection=yes',readonly=True)
	c = conn.cursor()
    query_params = ['%'+beaconid+'%', MEOLUT, start_date, end_date, ant_i, sat]
    sql_query = ('SELECT UplinkTOADate, UplinkFOA from MeolutPackets '
		'WHERE '
		'BcnId15 like ? '
		'AND '
		'MeolutId like ? '
		'AND ' 
		'AddTime between ? AND ? '
		'AND '
		'AntennaId like ? '
		'AND '
		'SatId like ? ' )
	#cursor.execute("Select * from MEOInputSolution where BcnId15 like ?", [BeaconQuery])
	#cursor.execute(sql_query,[MEOLUT,StartTime, EndTime, BeaconQuery])
	#for dataRow in cursor.fetchall():
	#    print(dataRow)
	#    crsr.execute(sql, dataRow)
	#df = pd.read_sql_query(sql_query,conn, index_col = 'addtime', params=query_params)
	#print df.head(5)
	# return df
    c.execute(sql_query, query_params)
    packets = c.fetchall()
    return packets

def plot_packets(packets, MEOLUT, ant_i,start_time,end_time, packets_found, percent_packets):
    global ax1
    frequencylist = list()
    timelist = list()
    velolist = list() 
    for packet in packets:
        frequencylist.append(packet[1])
        timelist.append(packet[0])
        #timelist.append(datetime.strptime(packet[12],timepacket_format))
    #if timelist:
    #    mintime = min(timelist)
    #    maxtime = max(timelist)
    #else:
        
    #print mintime
    #print maxtime
    #alt = [np.linalg.norm(x) for x in posilist]    
    #rangelist = [np.linalg.norm(MEOLUTLocDict[MEOLUT] - x) for x in posilist]
    #plotting TLE positional difference below
    #fig, ax = plt.subplots()
    #ax.plot_date(timelist, frequencylist, '-')
    #font = {'family' : 'normal',
            #'weight' : 'bold',
            #'size'   : 22}
    #matplotlib.rc('font', **font)
    #print frequencylist
    plt.figure(MEOLUT, figsize=(40,20))
    if ant_i == ant_list[0]:
        ax1 = plt.subplot(len(ant_list),1,1)
    else:
        plt.subplot(len(ant_list),1,ant_list.index(ant_i)+1, sharex = ax1, sharey = ax1)
    
    plt.plot(timelist, frequencylist,'ro')
    plt.title('{} - antenna {} -- {} packets = {:.1f}%'.format(MEOLUT,ant_i,packets_found,percent_packets))
    #plt.title('{} - antenna {} ---- {} packets'.format(MEOLUT,ant_i,packets_found)) #,percent_packets))
    plt.grid(True)
    #plt.gca().xaxis.set_major_locator(Hours)
    plt.gca().xaxis.set_major_formatter(plot_fmt)
    #plt.gca().xaxis.set_minor_locator(FiveMinutes)
    plt.gca().set_xlim(start_time,end_time)

MEOLUTName ={3669:'Florida',3385:'Hawaii',3677:'Maryland'}
MEOList = [3669, 3385, 3677]
MEOref = {3669:'ADDC002%', 3385:'AA5FC00%', 3677:'ADDC002%'}

#Date Formats
timepacket_format = '%Y-%m-%d %H:%M:%S.%f'
sec_f = '%S.%f'
plot_fmt = DateFormatter('%m-%d %H:%M')
Hours = MinuteLocator(interval = 30)
FiveMinutes = MinuteLocator(interval=5)


data_cols = ['DataType','BcnId15','BcnId30','SourceId','TimeFirst','TimeLast','Latitude',
    'Longitude','Altitude','NumBursts','NumPackets','DOP','ExpectedHorzError']
data_cols = [0,1,2,4,8,9,10,11,12,13,14,17,18,19,20,21,22,36,37,47]
ant_list = range(1,7)

def xlx_analysis(UPLOADFILE, OUTPUTFOLDER, MEOLUT, TimeStart, TimeEnd, result, Lat_GT=0, Long_GT=0, Location='', **kwargs):
    # need to add approot to any place a file is written if this will be functional on apache 
    # - done 7/12/17 in routes.py, UPLOADFILE is now full path - change may be needed in over functions 
    InputMEO_excelfile = UPLOADFILE
    CSVoutfolder = OUTPUTFOLDER
    BeaconID = result['beaconID']
    if ('Lat' in kwargs): 
        Lat_GT = kwargs['Lat']
    else: 
        Lat_GT = None
    if ('Long' in kwargs): 
        Long_GT = kwargs['Long']
        MEO_dist = haversine([Lat_GT,Long_GT,MEOLUTLoc[MEOLUT][0],MEOLUTLoc[MEOLUT][1]])
    else: 
        Long_GT = None
        MEO_dist = 'NA'
    
    #print('\n\nImporting - ' + InputMEO_excelfile)
    df = pd.read_excel(InputMEO_excelfile, index_col = 'TimeSolutionAdded') #, parse_dates = True) #, parse_cols =  data_cols) #parse_dates = True,
    df['TimeFirst']=pd.to_datetime(df['TimeFirst'], errors = 'ignore') ### FIX THIS WHEN TimeFirst is already a datetime.time 12/9 
    df['TimeLast']=pd.to_datetime(df['TimeLast'], errors = 'ignore')
    df['TimeSolutionGenerated']=pd.to_datetime(df['TimeSolutionGenerated'], errors = 'ignore')
    #df['TimeSolutionAdded']=pd.to_datetime(df['TimeSolutionAdded'])

    #df['DataType'] = df['DataType']
    #df.set_index(df['TimeSolutionAdded'],inplace = True)
    #df = df.drop(['BcnId36','FbiasDev', 'FreqDrift','SitFunc','MsgNum','QualityIndicator','NumAntennas','Srr', \
        #'PositionConfFlag','SortId','SortType','Distance'], axis = 1) -- No longer needed if I just slice into sub table
    #df.sort_values('TimeSolutionAdded').head()

    df2 = df[['DataType','BcnId15','BcnId30','SourceId','TimeFirst','TimeLast','Latitude',
        'Longitude','Altitude','NumBursts','NumPackets','DOP','ExpectedHorzError']]
    df2.index = df2.index.map(str.lower)
    df2 = df2.sort_index().ix[TimeStart:TimeEnd]
    df3 = df2[(df2.bcnid15 == BeaconID)]
    dfSB = df3[(df3.datatype == 3)] 
    dfMB = df3[(df3.datatype == 0)] 
    if df3.empty: 
        print "Data Frame is empty after filtering out Beacon ID = " + BeaconID

    lat_fun = lambda hexin: bcn.beacon(hexin).lat
    lon_fun = lambda hexin: bcn.beacon(hexin).lon
    dfSB['Enc_Lat'] = dfSB['bcnid30'].apply(lat_fun)
    dfSB['Enc_Lon'] = dfSB['bcnid30'].apply(lon_fun)
    dfMB['Enc_Lat'] = dfMB['bcnid30'].apply(lat_fun)
    dfMB['Enc_Lon'] = dfMB['bcnid30'].apply(lon_fun)

    df_SBL = singleburst_loc(dfSB,Lat_GT,Long_GT,MEOLUT)
    SBL = len(df_SBL)
    df5 = df_SBL[df_SBL.Error_GT < 5] if not df_SBL.empty else df_SBL
    df5_enc = df_SBL[df_SBL.Error_Enc < 5] if not df_SBL.empty else df_SBL
    df10 = df_SBL[df_SBL.Error_GT < 10] if not df_SBL.empty else df_SBL
    df10_enc = df_SBL[df_SBL.Error_Enc < 10] if not df_SBL.empty else df_SBL
    df20_enc = df_SBL[df_SBL.Error_Enc < 20] if not df_SBL.empty else df_SBL

    timefirst = df3.TimeFirst.min()
    timelast = df3.TimeLast.max()
    timediff = timelast - timefirst

    SBL_5 = len(df5)
    SBL_5_enc = len(df5_enc)
    SBL_10 = len(df10)
    SBL_10_enc = len(df10_enc)
    SBL_20_enc = len(df20_enc)

    error_SBL = df_SBL.Error_GT if not df_SBL.empty else df_SBL # not used currently

    expected_bursts = int(timediff/pd.Timedelta(seconds = 50))
    prob_SBL = float(SBL)/expected_bursts if expected_bursts != 0 else 0
    prob_SBL_5 =float(SBL_5)/SBL if SBL !=0 else 0
    prob_SBL_5_enc =float(SBL_5_enc)/SBL if SBL !=0 else 0
    prob_SBL_10 = float(SBL_10)/SBL if SBL !=0 else 0
    prob_SBL_10_enc = float(SBL_10_enc)/SBL if SBL !=0 else 0
    prob_SBL_20_enc = float(SBL_20_enc)/SBL if SBL !=0 else 0

    #print 'Analysis of MEOLUT -> {} - {}'.format(MEOLUTName[MEOLUT],MEOLUT)
    #print '\n Beacon Ground Truth Location used = {}, {}'.format(Lat_GT,Long_GT)
    #print ' Distance from MEOLUT = {:.1f} km'.format(haversine([Lat_GT,Long_GT,MEOLUTLoc[MEOLUT][0],MEOLUTLoc[MEOLUT][1]]))
    ##print ' Distance from MEOLUT = {:.1f} km'.format(haversine([Lat_GT,Long_GT,MEOlat,MEOlon]))
    #print ' Time of first burst = {:%Y-%m-%d %H:%M:%S}'.format(timefirst)
    #print ' Time of Last burst = {:%Y-%m-%d %H:%M:%S}'.format(timelast)
    #print ' Time Span = {}'.format(timediff)

    #print '\nSINGLE BURST ANALYSIS'
    #print 'Expected single burst locations = {}'.format(expected_bursts)
    #print '\n'
    #print 'Number of single burst locations = {}'.format(SBL)
    #print 'Probability of single burst location = {:.2%}'.format(prob_SBL)
    #print '\n'
    #print 'Number of single burst locations within 5 km = {}'.format(SBL_5)
    #print 'Percent of single burst locations within 5 km = {:.2%}'.format(prob_SBL_5)
    #print 'Number of single burst locations within 5 km (vs Encoded Location) = {}'.format(SBL_5_enc)
    #print 'Percent of single burst locations within 5 km (vs Encoded Location) = {:.2%}'.format(prob_SBL_5_enc)
    #print '\n'
    #print 'Number of single burst locations within 10 km = {}'.format(SBL_10)
    #print 'Percent of single burst locations within 10 km = {:.2%}'.format(prob_SBL_10)
    #print 'Number of single burst locations within 10 km (vs Encoded Location) = {}'.format(SBL_10_enc)
    #print 'Percent of single burst locations within 10 km (vs Encoded Location) = {:.2%}'.format(prob_SBL_10_enc)
    #print '\n'
    #print 'Number of single burst locations within 20 km (vs Encoded Location) = {}'.format(SBL_20_enc)
    #print 'Percent of single burst locations within 20 km (vs Encoded Location) = {:.2%}'.format(prob_SBL_20_enc)

    ## Multi Burst (Windowed) Section
    window_time = 20 #minutes - no longer used since now just look for change in TimeFirst
    window_span = pd.Timedelta(minutes = window_time)
    expected_windows = math.ceil(timediff/window_span)

    #print df3.head(5)

    df_MBL = multiburst_loc(dfMB, Lat_GT, Long_GT, MEOLUT, window_span)
    df_MBL5 = df_MBL[df_MBL.Error_GT < 5] if not df_MBL.empty else df_MBL
    df_MBL5_enc = df_MBL[df_MBL.Error_Enc < 5] if not df_MBL.empty else df_MBL
    df_MBL10 = df_MBL[df_MBL.Error_GT < 10] if not df_MBL.empty else df_MBL
    df_MBL10_enc = df_MBL[df_MBL.Error_Enc < 10] if not df_MBL.empty else df_MBL
    df_MBL20_enc = df_MBL[df_MBL.Error_Enc < 20] if not df_MBL.empty else df_MBL

    MBL = len(df_MBL)
    MBL_5 = len(df_MBL5)
    MBL_5_enc = len(df_MBL5_enc)
    MBL_10 = len(df_MBL10)
    MBL_10_enc = len(df_MBL10_enc)
    MBL_20_enc = len(df_MBL20_enc)

    error_MBL = df_MBL.Error_GT if not df_MBL.empty else df_MBL # not used currently

    prob_MBL = float(MBL)/expected_windows if expected_windows != 0 else 0
    prob_MBL_5 =float(MBL_5)/MBL if MBL !=0 else 0
    prob_MBL_5_enc =float(MBL_5_enc)/MBL if MBL !=0 else 0
    prob_MBL_10 = float(MBL_10)/MBL if MBL !=0 else 0
    prob_MBL_10_enc = float(MBL_10_enc)/MBL if MBL !=0 else 0
    prob_MBL_20_enc = float(MBL_20_enc)/MBL if MBL !=0 else 0

    #print '\n\nMULTIPLE BURST ANALYSIS'
    #print 'Multiple Burst (windowed) locations, Window = {}'.format(window_span)
    #print 'Expected number of windows = {}'.format(int(expected_windows))
    #print '\n'
    #print 'Number of windowed locations = {}'.format(MBL)
    #print 'Probability of windowed location = {:.2%}'.format(prob_MBL)
    #print '\n'
    #print 'Number of windowed locations within 5 km = {}'.format(MBL_5)
    #print 'Percent of windowed locations within 5 km = {:.2%}'.format(prob_MBL_5)
    #print 'Number of windowed locations within 5 km (vs Encoded Location) = {}'.format(MBL_5_enc)
    #print 'Percent of windowed locations within 5 km (vs Encoded Location) = {:.2%}'.format(prob_MBL_5_enc)
    #print '\n'
    #print 'Number of windowed locations within 10 km = {}'.format(MBL_10)
    #print 'Percent of windowed locations within 10 km = {:.2%}'.format(prob_MBL_10)
    #print 'Number of windowed locations within 10 km (vs Encoded Location) = {}'.format(MBL_10_enc)
    #print 'Percent of windowed locations within 10 km (vs Encoded Location) = {:.2%}'.format(prob_MBL_10_enc)
    #print '\n'
    #print 'Number of windowed locations within 20 km (vs Encoded Location) = {}'.format(MBL_20_enc)
    #print 'Percent of windowed locations within 20 km (vs Encoded Location) = {:.2%}'.format(prob_MBL_20_enc)

    outfilelist = list()
    outfiletag = '{}_{}_{:%Y-%m-%d-%H%M}_{:%Y-%m-%d-%H%M}'.format(MEOLUT,BeaconID,TimeStart,TimeEnd)
    SBLfile = OUTPUTFOLDER + '\SBL'+outfiletag +'.csv'
    MBLfile = OUTPUTFOLDER + '\MBL'+outfiletag +'.csv'
    OUTfile = OUTPUTFOLDER + '\OUT' + outfiletag +'.csv'
    df_SBL.to_csv(SBLfile)
    df_MBL.to_csv(MBLfile)
    outfilelist.append(SBLfile)
    outfilelist.append(MBLfile)
    outfilelist.append(OUTfile)
    
    with open(OUTfile, 'wb') as csvfile:
        csvoutwriter = csv.writer(csvfile, delimiter=',',
                                quoting=csv.QUOTE_MINIMAL)
        csvoutwriter.writerow(['MEOLUT', MEOLUTName[MEOLUT]])
        csvoutwriter.writerow(['MEOLUT_ID', MEOLUT])
        csvoutwriter.writerow(['BeaconID',BeaconID])
        csvoutwriter.writerow(['Location',Location])
        csvoutwriter.writerow(['TimeStart',TimeStart])
        csvoutwriter.writerow(['TimeEnd',TimeEnd])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['Ground Truth Lat',Lat_GT])
        csvoutwriter.writerow(['Ground Truth Long',Long_GT])
        csvoutwriter.writerow(['Distance From MEOLUT',MEO_dist]) #'{:.2f}'.format(MEO_dist)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['Time First Burst','{:%Y-%m-%d %H:%M:%S}'.format(timefirst)])    
        csvoutwriter.writerow(['Time Last Burst', '{:%Y-%m-%d %H:%M:%S}'.format(timelast)])
        csvoutwriter.writerow(['Time Span', timediff])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['SINGLE BURST LOCATIONS'])
        csvoutwriter.writerow(['ExpSBL',expected_bursts])
        csvoutwriter.writerow(['NumSBL',SBL])
        csvoutwriter.writerow(['ProbSBL','{:.2%}'.format(prob_SBL)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <5km', SBL_5])
        csvoutwriter.writerow(['% SBL <5km', '{:.2%}'.format(prob_SBL_5)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <10km', SBL_10])
        csvoutwriter.writerow(['% SBL <10km', '{:.2%}'.format(prob_SBL_10)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <5km (vs Enc)', SBL_5_enc])
        csvoutwriter.writerow(['% SBL <5km (vs Enc)', '{:.2%}'.format(prob_SBL_5_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <10km (vs Enc)', SBL_10_enc])
        csvoutwriter.writerow(['% SBL <10km (vs Enc)', '{:.2%}'.format(prob_SBL_10_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <20km (vs Enc)', SBL_20_enc])
        csvoutwriter.writerow(['% SBL <20km (vs Enc)', '{:.2%}'.format(prob_SBL_20_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['MULTIPLE BURST LOCATIONS'])
        csvoutwriter.writerow(['Window Period', window_span])
        csvoutwriter.writerow(['ExpMBL',expected_windows])
        csvoutwriter.writerow(['NumMBL',MBL])
        csvoutwriter.writerow(['ProbMBL','{:.2%}'.format(prob_MBL)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <5km', MBL_5])
        csvoutwriter.writerow(['% MBL <5km', '{:.2%}'.format(prob_MBL_5)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <10km', MBL_10])
        csvoutwriter.writerow(['% MBL <10km','{:.2%}'.format(prob_MBL_10)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <5km (vs Enc)', MBL_5_enc])
        csvoutwriter.writerow(['% MBL <5km (vs Enc)', '{:.2%}'.format(prob_MBL_5_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <10km (vs Enc)', MBL_10_enc])
        csvoutwriter.writerow(['% MBL <10km (vs Enc)','{:.2%}'.format(prob_MBL_10_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <20km (vs Enc)', MBL_20_enc])
        csvoutwriter.writerow(['% MBL <20km (vs Enc)','{:.2%}'.format(prob_MBL_20_enc)])

    #print '\nWrite KML? - ' + result['KMLgen']

    if 'KMLgen' in result:
        kml = simplekml.Kml()
        KMLfile = OUTPUTFOLDER + '\KML' + outfiletag +'.kml'
        #print '\nCreating KML file'
        if 'SingleBurstGen' in result:
            #print 'Writing Single Burst Locations to KML' 
            with open(SBLfile, 'rb') as csvfile:
                csvfile.next()
                filereader = csv.reader(csvfile)
                folSBL = kml.newfolder(name='Single Burst Locations - '+ str(MEOLUT))
                folEnc = kml.newfolder(name = 'Encoded Locations - '+ str(MEOLUT))
                for row in filereader:            
                    pntSBL = folSBL.newpoint(coords=[(float(row[8]),float(row[7]),float(row[9]))], 
                        description = 'Single Burst Solution \nBeacon = ' + row[2] + '\n\nTimeSolutionAdded = ' + row[0] + '\nTimeFirst = ' +row[5] + '\nTimeLast = ' +row[6] + 
                        '\nMEOLUT = ' + row[4] + '\nGT_Error = ' + row[16] + '\nEnc_Error = ' + row[17] +
                        '\nNum of Bursts = ' + row[10] + '\nNum of Packets = ' +row[11] +'\nDOP = ' + row[12] + 
                        '\nEHE = ' + row[13]
                        )
                    # name=str(row[0][11:19])
                    pntSBL.timespan.begin = row[0][:10] + 'T' + row[0][11:19]
                    pntSBL.style.iconstyle.icon.href = 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png'
        if 'EncLocGen' in result:
            #print 'Writing Encoded Locations to KML'
            with open(SBLfile, 'rb') as csvfile:
                csvfile.next()
                filereader = csv.reader(csvfile)
                folEnc = kml.newfolder(name = 'Encoded Locations - '+ str(MEOLUT))                
                for row in filereader:
                    if row[17] <> '':  
                        pntEnc = folEnc.newpoint(coords=[(float(row[15]),float(row[14]))], 
                            description = 'Encoded Location - Beacon = ' + row[2] + '\n\nTimeSolutionAdded = ' + row[0] + '\nLat,Long = (' + row[14] + ', ' +row[15] + ')'  
                            )
                        pntEnc.timespan.begin = row[0][:10] + 'T' + row[0][11:19]
                        pntEnc.style.iconstyle.icon.href = '/static/icons/track-none.png'
                        pntEnc.style.iconstyle.scale = 0.8
                        pntEnc.style.labelstyle.color = '00ff0000'  # Red
                    #pnt.snippet.content = 'this is content'
                    #print row[0],row[7],row[8]
        with open(MBLfile, 'rb') as csvfile:
            csvfile.next()
            filereader = csv.reader(csvfile)
            folMBL = kml.newfolder(name='Multi Burst Locations - '+ str(MEOLUT))
            for row in filereader:            
                pntMBL = folMBL.newpoint(coords=[(float(row[8]),float(row[7]),float(row[9]))], 
                    description = 'Multi Burst Location - Beacon = ' + row[2] + '\n\nTimeSolutionAdded = ' + row[0] + '\nTimeFirst = ' +row[5] + '\nTimeLast = ' +row[6] + 
                    '\nMEOLUT = ' + row[4] + '\nGT_Error = ' + row[16] + '\nEnc_Error = ' + row[17] + 
                    '\nNum of Bursts = ' + row[10] + '\nNum of Packets = ' +row[11] +'\nDOP = ' + row[12] + 
                    '\nEHE = ' + row[13]
                    )
                pntMBL.timespan.begin = row[0][:10] + 'T' + row[0][11:19]
                pntMBL.style.iconstyle.icon.href = '/static/icons/icon49.png'
                pntMBL.style.labelstyle.color = 'ff0000ff'  # Red
                #pnt.snippet.content = 'this is content'
                #print row[0],row[7],row[8]
    

    
    if 'LEOgen' in result:
        LEOinputfile = UPLOADFOLDER +'\\' + kwargs['LEOGEO_file']
        #print 'Reading LEO file - ' + LEOinputfile
        #print 'Writing LEO bursts to KML'
        LEOoutfile = OUTPUTFOLDER + '\LEO' + outfiletag + '.csv'
        df = pd.read_excel(LEOinputfile, index_col = 'AddTime') #, parse_dates = True)
        df = df[(df.BcnId15 == BeaconID)]
        if df.empty: 
            print(LEOinputfile + ' - did not contain any data that matched')    
        else:
            dfLEO = df[df.Orbit.notnull()]
            dfLEO_loc = dfLEO[dfLEO.A_Lat.notnull()]
            dfLEO_loc.to_csv(LEOoutfile)
            with open(LEOoutfile, 'rb') as csvfile:
                filereader = csv.reader(csvfile)
                csvfile.next()
                fol_LEO = kml.newfolder(name='LEO Locations - '+ str(MEOLUT))
                for row in filereader:            
                    pnt_LEO = fol_LEO.newpoint(coords=[(float(row[22]),float(row[21]))], 
                        description = 'LEO Location \nBeacon = ' + row[15] + '\n\nA_Tca = ' + row[23] + '\nMCCTime = ' + row[0] + '\n\nLUT = ' + row[2] + '\nSat = ' + row[3] +
                        '\nOrbit = ' + str(int(float(row[4]))) + '\n\nNominal = ' + row[73] +  
                        '\nNum of Points = ' +row[18] + '\nA_Cta =' + row[24] + '\nA_prob = ' +row[17] + '\nSolId = ' + row[1]  
                        )   
                    pnt_LEO.timespan.begin = row[0][:10] + 'T' + row[0][11:19]
                    pnt_LEO.style.iconstyle.icon.href = 'http://maps.google.com/mapfiles/kml/paddle/ylw-blank.png'
                    #pnt_LEO.style.iconstyle.icon.href = 'file://C:/Users/Jesse/Documents/Programming/Python/MEO_Input_Processor/MEO_Input_Processor_v2_w_KML/icon35.png'
                    pnt_LEO.style.iconstyle.scale = 0.7
                    pnt_LEO.style.labelstyle.color = 'ffff0000'  # Red

    kml.save(CSVoutfolder + '\KML_' + csvoutfilename + '.kml')

def parse_results(result, MEOList): 
    if result.get('UseBeaconID') == "FLref": 
        BeaconQuery = 'ADDC00202020201%'
        BeaconID = 'ADDC00202020201'
        Lat_GT = MEORefLoc[3669][0]
        Long_GT = MEORefLoc[3669][1]
        Location = 'Florida Ref Beacon'
        print 'Flref'
    elif result.get('UseBeaconID') == "HIref": 
        BeaconQuery = 'AA5FC00%'
        BeaconID = 'AA5FC0000000001'
        Lat_GT = MEORefLoc[3385][0]
        Long_GT = MEORefLoc[3385][1]
        Location = 'Hawaii Ref Beacon'
        print 'HIref'
    else:
        BeaconQuery = '%' + result.get('beaconID')+'%'  ### FIX HERE
        BeaconID = result['beaconID']
        if 'beaconLat' in result and result['beaconLat'] <> '':
            Lat_GT = float(result['beaconLat'])
        if 'beaconLon' in result and result['beaconLon'] <> '':
            Long_GT = float(result['beaconLon'])
        else: 
            Lat_GT = None
            Long_GT = None

    
    MEO_dist = []
    for MEO in MEOList:
        MEO_dist.append(haversine([Lat_GT,Long_GT,MEOLUTLoc[MEO][0],MEOLUTLoc[MEO][1]]))
    if 'Location' in result:
        Location = result['Location']
    else: Location = 'NA'
    return BeaconQuery, BeaconID, Lat_GT, Long_GT, Location, MEO_dist

def MSSQL_analysis(result, TimeStart, TimeEnd, OUTPUTFOLDER, approot, servername = 'localhost', databasename='mccoperational', Lat_GT=0, Long_GT=0, Location='', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)

    MEOList = []
    if 'MEOLUT_HI' in result: MEOList.append(3385)
    if 'MEOLUT_FL' in result: MEOList.append(3669)
    if 'MEOLUT_FR' in result: MEOList.append(2276)

    BeaconQuery, BeaconID, Lat_GT, Long_GT, Location, MEO_dist = parse_results(result,MEOList)
    sql_query = ('SELECT * FROM '
                    'InputMEOSolution ' 
                    'WHERE ' 
                    'TimeSolutionGenerated between ? AND ? '
                    'AND '
                    'BcnId15 LIKE ? '
                    )
    params=[TimeStart, TimeEnd, BeaconQuery]

    df = pd.read_sql_query(sql_query,conn, index_col = 'timesolutionadded', params=params)
    df_data = []
    for MEO in MEOList:
        df_data.append(filter1(df,'sourceid',MEO))
    dfMEO = pd.concat(df_data)

    if len(MEOList) == 1:
        MEOLUT = MEOList[0]

    #    parse_dates=['timefirst','timelast', 'timesolutiongenerated','timesolutionadded'])
    #df = pd.DataFrame(cursor.fetchall())
    #print df.head(5)
    #df.columns = pd.DataFrame(np.matrix(cursor.description))[0]
    df2 = dfMEO[['datatype','bcnid15','bcnid30','sourceid','timefirst','timelast','latitude',
        'longitude','altitude','numbursts','numpackets','dop','expectedhorzerror']]
    df3 = df2.sort_index().ix[TimeStart:TimeEnd]
    #df3 = df2[(df2.BcnId15 == BeaconID)]
    dfSB = df3[(df3.datatype == 3)] 
    dfMB = df3[(df3.datatype == 0)] 
    if df3.empty: 
        print "Data Frame is empty after filtering out Beacon ID = " + BeaconID
        return None, { 'MEOLUT': MEOLUT,
                        'TimeStart': TimeStart,
                        'TimeEnd': TimeEnd,
                        'Beacon': BeaconQuery,
                      }
    
    lat_fun = lambda hexin: bcn.beacon(hexin).lat
    lon_fun = lambda hexin: bcn.beacon(hexin).lon
    dfSB['Enc_Lat'] = dfSB['bcnid30'].apply(lat_fun)
    dfSB['Enc_Lon'] = dfSB['bcnid30'].apply(lon_fun)
    dfMB['Enc_Lat'] = dfMB['bcnid30'].apply(lat_fun)
    dfMB['Enc_Lon'] = dfMB['bcnid30'].apply(lon_fun)
    
    df_SBL = singleburst_loc(dfSB,Lat_GT,Long_GT,MEOLUT)
    SBL = len(df_SBL)
    df5 = df_SBL[df_SBL.Error_GT < 5] if not df_SBL.empty else df_SBL
    df5_enc = df_SBL[df_SBL.Error_Enc < 5] if not df_SBL.empty else df_SBL
    df10 = df_SBL[df_SBL.Error_GT < 10] if not df_SBL.empty else df_SBL
    df10_enc = df_SBL[df_SBL.Error_Enc < 10] if not df_SBL.empty else df_SBL
    df20_enc = df_SBL[df_SBL.Error_Enc < 20] if not df_SBL.empty else df_SBL

    timefirst = df3.timefirst.min()
    timelast = df3.timelast.max()
    timediff = timelast - timefirst

    SBL_5 = len(df5)
    SBL_5_enc = len(df5_enc)
    SBL_10 = len(df10)
    SBL_10_enc = len(df10_enc)
    SBL_20_enc = len(df20_enc)

    error_SBL = df_SBL.Error_GT if not df_SBL.empty else df_SBL # not used currently

    expected_bursts = int(timediff/pd.Timedelta(seconds = 50))
    prob_SBL = float(SBL)/expected_bursts if expected_bursts != 0 else 0
    prob_SBL_5 =float(SBL_5)/SBL if SBL !=0 else 0
    prob_SBL_5_enc =float(SBL_5_enc)/SBL if SBL !=0 else 0
    prob_SBL_10 = float(SBL_10)/SBL if SBL !=0 else 0
    prob_SBL_10_enc = float(SBL_10_enc)/SBL if SBL !=0 else 0
    prob_SBL_20_enc = float(SBL_20_enc)/SBL if SBL !=0 else 0

    ## Multi Burst (Windowed) Section
    window_time = 20 #minutes - no longer used since now just look for change in TimeFirst
    window_span = pd.Timedelta(minutes = window_time)
    expected_windows = math.ceil(timediff/window_span)

    #print df3.head(5)

    df_MBL = multiburst_loc(dfMB, Lat_GT, Long_GT, MEOLUT, window_span)
    df_MBL5 = df_MBL[df_MBL.Error_GT < 5] if not df_MBL.empty else df_MBL
    df_MBL5_enc = df_MBL[df_MBL.Error_Enc < 5] if not df_MBL.empty else df_MBL
    df_MBL10 = df_MBL[df_MBL.Error_GT < 10] if not df_MBL.empty else df_MBL
    df_MBL10_enc = df_MBL[df_MBL.Error_Enc < 10] if not df_MBL.empty else df_MBL
    df_MBL20_enc = df_MBL[df_MBL.Error_Enc < 20] if not df_MBL.empty else df_MBL

    MBL = len(df_MBL)
    MBL_5 = len(df_MBL5)
    MBL_5_enc = len(df_MBL5_enc)
    MBL_10 = len(df_MBL10)
    MBL_10_enc = len(df_MBL10_enc)
    MBL_20_enc = len(df_MBL20_enc)

    error_MBL = df_MBL.Error_GT if not df_MBL.empty else df_MBL # not used currently

    prob_MBL = float(MBL)/expected_windows if expected_windows != 0 else 0
    prob_MBL_5 =float(MBL_5)/MBL if MBL !=0 else 0
    prob_MBL_5_enc =float(MBL_5_enc)/MBL if MBL !=0 else 0
    prob_MBL_10 = float(MBL_10)/MBL if MBL !=0 else 0
    prob_MBL_10_enc = float(MBL_10_enc)/MBL if MBL !=0 else 0
    prob_MBL_20_enc = float(MBL_20_enc)/MBL if MBL !=0 else 0
    

    outfiletag = '_{}_{:%Y-%m-%d-%H%M}_{:%Y-%m-%d-%H%M}'.format(BeaconID,TimeStart,TimeEnd)
    SBLfile = os.path.join(OUTPUTFOLDER, 'SBL' + str(MEOLUT) + outfiletag +'.csv')
    MBLfile = os.path.join(OUTPUTFOLDER, 'MBL' + str(MEOLUT) + outfiletag +'.csv')
    OUTfile = os.path.join(OUTPUTFOLDER, 'OUT' + str(MEOLUT) + outfiletag +'.csv')
    LEOGEO_file = os.path.join(OUTPUTFOLDER, 'LEO' + outfiletag + '.csv')
    RCC_Output_file = os.path.join(OUTPUTFOLDER, 'RCC' + outfiletag + '.csv')
    #outfilenamelist = list()
    outfilelist = OrderedDict()
    outfilelist[OUTfile] = 'Output Summary'
    outfilelist[SBLfile] = 'Single Burst Solutions'
    outfilelist[MBLfile] = 'Multi Burst Solutions'




    
    if 'KMLgen' in result: 
        KMLfile = os.path.join(OUTPUTFOLDER, 'KML' + outfiletag +'.kml')
        Mapfile = os.path.join('/MapTest?KML=' + KMLfile).replace("\\","/")
        outfilelist[KMLfile] = 'KML File Output'
        outfilelist[Mapfile] = 'MapIt'
    df_SBL.to_csv(os.path.join(approot,SBLfile))
    df_MBL.to_csv(os.path.join(approot,MBLfile))
    #OrderedDict(reversed(list(outfilelist.items())))
    #outfilelist.append(SBLfile)
    #outfilelist.append(MBLfile)
    #outfilelist.append(OUTfile)


    with open(os.path.join(approot,OUTfile), 'wb') as csvfile:
        csvoutwriter = csv.writer(csvfile, delimiter=',',
                                quoting=csv.QUOTE_MINIMAL)
        csvoutwriter.writerow(['MEOLUT', MEOLUTName[MEOLUT]])
        csvoutwriter.writerow(['MEOLUT_ID', MEOLUT])
        csvoutwriter.writerow(['BeaconID',BeaconID])
        csvoutwriter.writerow(['Location',Location])
        csvoutwriter.writerow(['TimeStart',TimeStart])
        csvoutwriter.writerow(['TimeEnd',TimeEnd])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['Ground Truth Lat',Lat_GT])
        csvoutwriter.writerow(['Ground Truth Long',Long_GT])
        csvoutwriter.writerow(['Distance From MEOLUT',MEO_dist]) #'{:.2f}'.format(MEO_dist)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['Time First Burst','{:%Y-%m-%d %H:%M:%S}'.format(timefirst)])    
        csvoutwriter.writerow(['Time Last Burst', '{:%Y-%m-%d %H:%M:%S}'.format(timelast)])
        csvoutwriter.writerow(['Time Span', timediff])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['SINGLE BURST LOCATIONS'])
        csvoutwriter.writerow(['ExpSBL',expected_bursts])
        csvoutwriter.writerow(['NumSBL',SBL])
        csvoutwriter.writerow(['ProbSBL','{:.2%}'.format(prob_SBL)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <5km', SBL_5])
        csvoutwriter.writerow(['% SBL <5km', '{:.2%}'.format(prob_SBL_5)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <10km', SBL_10])
        csvoutwriter.writerow(['% SBL <10km', '{:.2%}'.format(prob_SBL_10)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <5km (vs Enc)', SBL_5_enc])
        csvoutwriter.writerow(['% SBL <5km (vs Enc)', '{:.2%}'.format(prob_SBL_5_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <10km (vs Enc)', SBL_10_enc])
        csvoutwriter.writerow(['% SBL <10km (vs Enc)', '{:.2%}'.format(prob_SBL_10_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumSBL <20km (vs Enc)', SBL_20_enc])
        csvoutwriter.writerow(['% SBL <20km (vs Enc)', '{:.2%}'.format(prob_SBL_20_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['MULTIPLE BURST LOCATIONS'])
        csvoutwriter.writerow(['Window Period', window_span])
        csvoutwriter.writerow(['ExpMBL',expected_windows])
        csvoutwriter.writerow(['NumMBL',MBL])
        csvoutwriter.writerow(['ProbMBL','{:.2%}'.format(prob_MBL)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <5km', MBL_5])
        csvoutwriter.writerow(['% MBL <5km', '{:.2%}'.format(prob_MBL_5)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <10km', MBL_10])
        csvoutwriter.writerow(['% MBL <10km','{:.2%}'.format(prob_MBL_10)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <5km (vs Enc)', MBL_5_enc])
        csvoutwriter.writerow(['% MBL <5km (vs Enc)', '{:.2%}'.format(prob_MBL_5_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <10km (vs Enc)', MBL_10_enc])
        csvoutwriter.writerow(['% MBL <10km (vs Enc)','{:.2%}'.format(prob_MBL_10_enc)])
        csvoutwriter.writerow([])
        csvoutwriter.writerow(['NumMBL <20km (vs Enc)', MBL_20_enc])
        csvoutwriter.writerow(['% MBL <20km (vs Enc)','{:.2%}'.format(prob_MBL_20_enc)])

    if 'KMLgen' in result:
        #print '\nCreating KML file'
        kml = simplekml.Kml()
        if Lat_GT <> 0:
            firstrad = 5000
            secondrad = 10000
            folEnc = kml.newfolder(name = 'Ground Truth - '+ str(MEOLUT))                
            polycircle1 = polycircles.Polycircle(latitude=Lat_GT,
                                    longitude=Long_GT,
                                    radius=firstrad,
                                    number_of_vertices=36)            
            pol1 = kml.newpolygon(name="5km",
                                         outerboundaryis=polycircle1.to_kml())
            pol1.style.polystyle.color = \
                simplekml.Color.changealphaint(100, simplekml.Color.green)
            # Second region

            polycircle2outer = polycircles.Polycircle(latitude=Lat_GT,
                                    longitude=Long_GT,
                                    radius=secondrad,
                                    number_of_vertices=36)            

            pol2 = kml.newpolygon(name="10km",
                                         outerboundaryis=polycircle2outer.to_kml(),
                                         innerboundaryis = polycircle1.to_kml())
            pol2.style.polystyle.color = \
                simplekml.Color.changealphaint(100, simplekml.Color.yellow)
            pntEnc = folEnc.newpoint(
                name = 'Ground Truth',
                coords=[(Long_GT,Lat_GT)], 
                description = 'Lat,Long = (' + str(Lat_GT) + ', ' + str(Long_GT) + ')'  
                )
            pntEnc.style.iconstyle.icon.href = '/static/icons/arrow.png'
            pntEnc.style.iconstyle.scale = 0.8
            pntEnc.style.labelstyle.color = '00ff0000'  # Red
        if 'SingleBurstGen' in result:
            with open(os.path.join(approot,SBLfile), 'rb') as csvfile:
                csvfile.next()
                filereader = csv.reader(csvfile)
                folSBL = kml.newfolder(name='Single Burst Locations - '+ str(MEOLUT))
                folEnc = kml.newfolder(name = 'Encoded Locations - '+ str(MEOLUT))
                for row in filereader:            
                    pntSBL = folSBL.newpoint(
                        name = row[0],
                        coords=[(float(row[8]),float(row[7]),float(row[9]))], 
                        description = 'Single Burst Solution \nBeacon = ' + row[2] + '\nLat,Long,Alt = ' + row[7] + 
                        ', ' + row[8] + ', ' + row[9] + 
                        '\nTimeSolutionAdded = ' + row[0] + '\nTimeFirst = ' +row[5] + '\nTimeLast = ' +row[6] + 
                        '\nMEOLUT = ' + row[4] + '\nGT_Error = ' + row[16] + '\nEnc_Error = ' + row[17] +
                        '\nNum of Bursts = ' + row[10] + '\nNum of Packets = ' +row[11] +'\nDOP = ' + row[12] + 
                        '\nEHE = ' + row[13]
                        )
                    # name=str(row[0][11:19])
                    pntSBL.timespan.begin = row[0][:10] + 'T' + row[0][11:19]
                    pntSBL.style.iconstyle.icon.href = '/static/icons/icon26.png'
        if 'EncLocGen' in result:
            with open(os.path.join(approot,MBLfile), 'rb') as csvfile:
                csvfile.next()
                filereader = csv.reader(csvfile)
                folEnc = kml.newfolder(name = 'Encoded Locations - '+ str(MEOLUT))                
                for row in filereader:
                    if row[17] <> '':  
                        pntEnc = folEnc.newpoint(
                            name= row[0],
                            coords=[(float(row[15]),float(row[14]))], 
                            description = 'Encoded Location - Beacon = ' + row[2] + '\nTimeSolutionAdded = ' + 
                        row[0] + '\nLat,Long = (' + row[14] + ', ' +row[15] + ')'  
                            )
                        pntEnc.timespan.begin = row[0][:10] + 'T' + row[0][11:19]
                        pntEnc.style.iconstyle.icon.href = '/static/icons/track-none.png'
                        pntEnc.style.iconstyle.scale = 0.8
                        pntEnc.style.labelstyle.color = '00ff0000'  # Red
                        pntEnc.style.labelstyle.scale = 0 
        with open(os.path.join(approot,MBLfile), 'rb') as csvfile:
            csvfile.next()
            filereader = csv.reader(csvfile)
            folMBL = kml.newfolder(name='Multi Burst Locations - '+ str(MEOLUT))
            for row in filereader:            
                pntMBL = folMBL.newpoint(
                    name=row[0],
                    coords=[(float(row[8]),float(row[7]),float(row[9]))], 
                    description = 'Multi Burst Location - Beacon = ' + row[2] + '\nLat,Long,Alt = ' + row[7] + 
                    ', ' + row[8] + ', ' + row[9] + '\nTimeSolutionAdded = ' + row[0] + '\nTimeFirst = ' + 
                    row[5] + '\nTimeLast = ' +row[6] + 
                    '\nMEOLUT = ' + row[4] + '\nGT_Error = ' + row[16] + '\nEnc_Error = ' + row[17] + 
                    '\nNum of Bursts = ' + row[10] + '\nNum of Packets = ' +row[11] +'\nDOP = ' + row[12] + 
                    '\nEHE = ' + row[13]
                    )
                pntMBL.timespan.begin = row[0][:10] + 'T' + row[0][11:19]
                pntMBL.style.iconstyle.icon.href = '/static/icons/icon49.png'
                pntMBL.style.iconstyle.scale = 0.8 
                pntMBL.style.labelstyle.color = 'ff0000ff'  # Red
                pntMBL.style.labelstyle.scale = 0 
        if 'LEOGen' in result:
            outfilelist[LEOGEO_file] = 'LEO Solutions'
            sql_query = ('SELECT b.AddTime, a.* from Lut406Solution a, inputmessage b '
                'WHERE a.InMsgId = b.InMsgId '
                'AND '
                'Orbit <> ? '  #this gets LEO solutions
                'AND '
                'A_Tca between ? AND ? '
                'AND '
                'BcnId15 LIKE ? '
                )
            params=['Null',TimeStart, TimeEnd, BeaconQuery]
            df = pd.read_sql_query(sql_query,conn, index_col = 'addtime', params=params)
            #df = df[(df.BcnId15 == BeaconID)]
            dfLEO_loc = df[df['a_lat'] != 'NULL']
            if df.empty: 
                print('query did not find any data that matched')    
            else:
                #dfLEO = df[df.Orbit.notnull()]

                dfLEO_loc.to_csv(os.path.join(approot,LEOGEO_file))
                with open(os.path.join(approot,LEOGEO_file), 'rb') as csvfile:
                    filereader = csv.reader(csvfile)
                    csvfile.next()
                    fol_LEO = kml.newfolder(name='LEO Locations')
                    for row in filereader:            
                        pnt_LEO = fol_LEO.newpoint(coords=[(float(row[22]),float(row[21]))], 
                            description = 'LEO Location \nBeacon = ' + row[15] + '\n' + '\nLat,Long = ' + 
                            row[21] + ', ' + row[22] + 
                            '\n\nA_Tca = ' + row[23] + '\nMCCTime = ' + row[0] + '\n\nLUT = ' + row[2] + '\nSat = ' + row[3] +
                            '\nOrbit = ' + str(int(float(row[4]))) + '\n\nNominal = ' + row[73] +  
                            '\nNum of Points = ' +row[18] + '\nA_Cta =' + row[24] + '\nA_prob = ' +row[17] + '\nSolId = ' + row[1]  
                            )   
                        pnt_LEO.timespan.begin = row[0][:10] + 'T' + row[0][11:19]
                        pnt_LEO.style.iconstyle.icon.href = '/static/icons/icon43.png'
                        #pnt_LEO.style.iconstyle.icon.href = 'file://C:/Users/Jesse/Documents/Programming/Python/MEO_Input_Processor/MEO_Input_Processor_v2_w_KML/icon35.png'
                        pnt_LEO.style.iconstyle.scale = 0.7
                        pnt_LEO.style.labelstyle.color = 'ffff0000'  # Red
        if 'OutputSolution' in result:
            outfilelist[RCC_Output_file] = 'RCC Output Solutions'
            sql_query = (' '
                #'declare @bcnid as varchar(15) '
                #'declare @bcnid2 as varchar(17) '
                #'set @bcnid= ? '
                #'set @bcnid2= "%" + @bcnid + "%" '
                'SELECT b.AddTime, b.AlertSiteSolId, b.TimeFirst, b.TimeLast,b.Tca, a.MsgName, '
                'b.SolReal, b.EncReal, b.AlertMsgState, c.ComSiteName, c.DestMcc, '
                'b.PrevSarNameList, b.CurSarNameList, b.SourceId,b.SourceId2, b.EncLat, '
                'b.EncLon, b.Latitude, b.Longitude, b.A_Lat, b.A_Lon, b.B_Lat, b.B_Lon, '
                'a.TableName, a.InMsgId, b.SourceNameRccMsg, b.BcnId15, b.RegBcnId15, '
                'b.SatelliteIds, b.Sat, c.SitNum, b.ASiteDuration  '
                'FROM OutputMessage a, OutSolution b, OutputProcess c '
                'WHERE '
                'b.TimeFirst > ? '
                'AND ' 
                'b.TimeLast < ? '
                'AND '
                'b.BcnId15 like ? '
                'AND (b.OutMsgId=a.OutMsgId AND c.OutMsgId=a.OutMsgId) '                
                )
            params=[TimeStart, TimeEnd, BeaconQuery]
            df = pd.read_sql_query(sql_query,conn, params=params)
            #df = df[(df.BcnId15 == BeaconID)]
            if df.empty: 
                print('query did not find any RCC output data that matched')    
            else:
                #dfLEO = df[df.Orbit.notnull()]
                dfRCC_loc = df[df.a_lat.notnull()]
                dfRCC_loc.to_csv(os.path.join(approot,RCC_Output_file))
                with open(os.path.join(approot,RCC_Output_file), 'rb') as csvfile:
                    filereader = csv.reader(csvfile)
                    csvfile.next()
                    fol_RCC = kml.newfolder(name='RCC Output Locations')
                    for row in filereader:  
                        if row[18]:
                            #print row
                            pnt_RCC = fol_RCC.newpoint(coords=[(float(row[19]),float(row[18]))], 
                                description = 'RCC Solution \nBeacon = ' + row[27] + '\n' 
                                '\nLat,Long = {0:.2f}'.format(float(row[18])) + ',{0:.2f}'.format(float(row[19])) +
                                '\nAddTime = ' + row[1] + '\nAlertSiteSolId = ' + row[2] +
                                '\nMsgName = ' + row[6] + '\n\nLUT = ' + row[14] + '\nSat = ' 
                                )   
                            pnt_RCC.timespan.begin = row[1][:10] + 'T' + row[1][11:19]
                            pnt_RCC.style.iconstyle.icon.href = '/static/icons/arrow2.png'
                            #pnt_LEO.style.iconstyle.icon.href = 'file://C:/Users/Jesse/Documents/Programming/Python/MEO_Input_Processor/MEO_Input_Processor_v2_w_KML/icon35.png'
                            pnt_RCC.style.iconstyle.scale = 0.7
                            pnt_RCC.style.labelstyle.color = 'FFFFFF'  # Red
            
        kml.save(os.path.join(approot,KMLfile))
    return OUTfile, outfilelist

def MSSQL_burst(result, MEOLUTlist, TimeStart, TimeEnd, OUTPUTFOLDER, approot, servername, databasename='MccTestLGM', **kwargs):
    if result['UseBeaconID'] == "FLref": 
        beaconIDstring = "ADDC002%"
        ref_flag = True
    elif result['UseBeaconID'] == "HIref": 
        beaconIDstring = "AA5FC00%"
        ref_flag = True
    elif 'beaconID' in result:
        beaconIDstring = result['beaconID']
    else:
        beaconIDstring = '%'
    if result['RealPastTime'] == 'RT_yes':
        TimeEnd = datetime.utcnow()
        TimeStart = TimeEnd - timedelta(hours = float(result['realtimehours']))
    TimeSpan = TimeEnd - TimeStart
    num_bursts = TimeSpan.total_seconds() / 50
    filetimetag = datetime.strftime(datetime.utcnow(),"%Y%m%d_%H%M%S")
    ref_flag = False
    filelist = list()
    MEOnamelist = list()
    for MEOLUT in MEOLUTlist:
        for ant_i in ant_list:
            if result['UseBeaconID'] == 'REFref': 
                beaconIDstring = MEOref[MEOLUT]
                ref_flag = True
            outpackets = find_packets(servername, databasename,beaconIDstring, TimeStart,TimeEnd, MEOLUT, ant_i, **kwargs) # sat 
            num_packets_found = len(outpackets)
            percent_packets = (num_packets_found/num_bursts)*100
            #print '{} - antenna {} ->  {} packets found -- {:.1f}% '.format(MEOLUT, ant_i, packets_found, percent_packets)
            plot_packets(outpackets, MEOLUT, ant_i,TimeStart,TimeEnd, num_packets_found, percent_packets)
        filename = os.path.normpath(os.path.join(OUTPUTFOLDER, str(MEOLUT) + '_' + filetimetag + '_output.png'))
        filelist.append(filename)
        MEOnamelist.append(MEOLUTName[MEOLUT])
        plt.savefig(os.path.join(approot, filename)) #, bbox_inches='tight')
        plt.clf()
        plt.cla()

    #print MEOnamelist

    return filelist
        
#servername = r'.\SQLEXPRESS'
#databasename = 'mccoperational'
def MEOLUT_alarms(StartTime, EndTime, servername = 'localhost', databasename = 'mccoperational', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    query_params = [StartTime, EndTime]
    sql_query = ('SELECT * from MeolutAlarms '
        'WHERE '
        'AddTime BETWEEN ? AND ? '
    )
    df = pd.read_sql_query(sql_query,conn, index_col = 'msgtime', params=query_params)
    df.sort_index().ix[StartTime:EndTime]

    dfClosedlist = df.alarmid[df.alarmtimeon.isnull()].tolist()
    dfClosed = df[df.alarmid.isin(dfClosedlist)]
     #list of closed alarmes between start and end time
    closedalarms = dfClosed.alarmid.unique().tolist()    
    #list of open alarms as of end time
    dfOpen = df[~df.alarmid.isin(dfClosedlist)]

    openalarms = dfOpen.alarmid.unique().tolist()
    numalarms = len(openalarms)
    alarmlist = []
    for alarm in openalarms:    
        alarms = {
            'alarmid': int(dfOpen[(dfOpen.alarmid == alarm)].iloc[0].alarmid),
            'meolutname': dfOpen[(dfOpen.alarmid == alarm)].iloc[0].meolutname,
            'alarmtext': dfOpen[(dfOpen.alarmid == alarm)].iloc[0].alarmtext,
            'openat': dfOpen[(dfOpen.alarmid == alarm)].iloc[0].alarmtimeon,
            'stillopen': dfOpen[(dfOpen.alarmid == alarm)].iloc[-1].alarmtimeon
        }
        alarmlist.append(alarms)
    closedalarmlist = []
    for alarm in closedalarms:    
        alarms = {
            'alarmid': int(dfClosed[(dfClosed.alarmid == alarm)].iloc[0].alarmid),
            'meolutname': dfClosed[(dfClosed.alarmid == alarm)].iloc[0].meolutname,
            'alarmtext': dfClosed[(dfClosed.alarmid == alarm)].iloc[0].alarmtext,
            'openat': dfClosed[(dfClosed.alarmid == alarm)].iloc[0].alarmtimeon,
            'closedat': dfClosed[(dfClosed.alarmid == alarm) & (dfClosed.alarmtimeon.isnull())].iloc[0].alarmtimeoff
            
        }
        #closedate = dfClosed[(dfClosed.alarmid == alarm) & (dfClosed.alarmtimeon.isnull())].alarmtimeoff
        #print closedate    
        closedalarmlist.append(alarms)
    return alarmlist, closedalarmlist, numalarms

def MEOLUT_status(StartTime, EndTime, servername = 'localhost', databasename = 'mccoperational', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    #StartTime = StartTime - timedelta(days=5) ### REMOVE this when you have data that is more current
    query_params = [StartTime, EndTime]
    sql_query = ('SELECT * from MeolutStatus '
        'WHERE '
        'AddTime BETWEEN ? AND ? '
    )
    df = pd.read_sql_query(sql_query,conn, index_col = 'msgtime', params=query_params)
    df.sort_index().ix[StartTime:EndTime]
    if df.empty: 
        HI = {'component': 'N/A',
            'msgtime': 'N/A',
            'status': 'N/A',
            }
        FL = {'component': 'N/A',
            'msgtime': 'N/A',
            'status': 'N/A',
            }
        return HI, FL
        #raise Exception('no status messages in window between start and endtime')
    else:
        dfHIcurrentmsgnum = int(df[(df.meolutid == 3385)].iloc[-1].msgnum)
        dfFLcurrentmsgnum = int(df[(df.meolutid == 3669)].iloc[-1].msgnum)
        dfHI = df[(df.meolutid == 3385) & (df.msgnum == dfHIcurrentmsgnum)]
        dfFL = df[(df.meolutid == 3669) & (df.msgnum == dfFLcurrentmsgnum)]
        statusHIlist = []
        statusFLlist = []
        statusHI = OrderedDict
        statusFL = OrderedDict
        for item, row in dfHI.iterrows():
            statusHI = {
                'component': row['component'],
                'msgtime': item,
                'status': int(row['status']),
                }
            statusHIlist.append(statusHI)
        for item, row in dfFL.iterrows():
            statusFL = {
                'component': row['component'],
                'msgtime': item,
                'status': int(row['status']),
                }
            statusFLlist.append(statusFL)
    return statusHIlist, statusFLlist

def MEOLUT_percent(StartTime, EndTime, servername = 'localhost', databasename = 'MccTestLGM', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    c = conn.cursor()
    def get_packets(BeaconID, MEOLUT, Antenna, StartTime, EndTime):
        query_params = [BeaconID, MEOLUT,  Antenna, StartTime, EndTime]
        sql_query = ('SELECT COUNT(*) from MeolutPackets '
            'WHERE '
            'BcnId15 like ? '
            'AND '
            'MeolutId like ? '
            'AND ' 
            'AntennaId like ? '
            'AND '
            'UplinkTOADate between ? AND ? '
             )
        c.execute(sql_query, query_params)
        numpackets = c.fetchone()[0]
        return numpackets

    TimeSpan = EndTime - StartTime
    expected_bursts = TimeSpan.total_seconds() / 50
    antlist = range(1,7)
    percentdict = defaultdict(dict)

    beaconIDstring = "ADDC002%"
    for ant in ant_list:
        numpackets = get_packets(beaconIDstring, 3669, ant, StartTime,EndTime)
        percentdict['FL'][ant] = round((numpackets / expected_bursts) * 100,2)
    beaconIDstring = "AA5FC00%"
    for ant in ant_list:
        numpackets = get_packets(beaconIDstring, 3385, ant, StartTime,EndTime)
        percentdict['HI'][ant] = round((numpackets / expected_bursts) * 100,2)
    return percentdict

def Open_Sites(servername = 'localhost', databasename = 'MccTestLGM', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    c = conn.cursor()
    params = ['N']
    sql_query = ('SELECT alertsitenum, bcnid15, midname, '
        'complat, complon, opentime, lastupdtime, numpasses, '
        'numsol, numleogeosol, nummeosol, numdopsol, numdoasol '
        ' from AlertSiteSum '
        'WHERE '
        'Closed = ? '
        )
    c.execute(sql_query, params)
    return c.fetchall()

def alertsitesum_query(sitenum, OUTPUTFOLDER, approot,servername = 'localhost', databasename = 'MccTestLGM', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    c = conn.cursor()
    params = [sitenum]
    sql_query = ('SELECT alertsitenum, bcnid15, midname, '
        'complat, complon, opentime, lastupdtime, numpasses, '
        'numsol, numleogeosol, nummeosol, numdopsol, numdoasol '
        ' from AlertSiteSum '
        'WHERE '
        'alertsitenum = ? '
        )
    c.execute(sql_query, params)
    return c.fetchall()

def alertsitesol_query(sitenum, OUTPUTFOLDER, approot,servername = 'localhost', databasename = 'MccTestLGM', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    c = conn.cursor()
    params = [sitenum]
    sql_query = ('select alertsitesolid, inputdatatype, bcnid15, framesync, '
        'complat, complon, sitfunc, gentime, addtime, sourceid, sourcename, '
        'sourcemccname, numbursts, numpackets, numsatellites, dop, latitude, '
        'longitude, a_lat, a_lon, MatchDistance, AlertMsgState, ExpectedHorzError, Sat, Tca '
        'from AlertSiteSol where '
        'AlertSiteNum = ? '
        'order by gentime '
        )
    c.execute(sql_query, params)
    insols = c.fetchall()
    KMLfile = False
    if "makeKML" in kwargs:
        if kwargs.get("makeKML"):
            KMLfile = os.path.join(OUTPUTFOLDER, 'KML_Input_site_' + sitenum +'.kml')
            kml = simplekml.Kml()
            fol_RCC = kml.newfolder(name='Input Locations')
            for row in insols:  
                        if (row[16] <> 'NULL') or row[18]:
                            if row[16] <> 'NULL':
                                pnt_RCC = fol_RCC.newpoint(coords=[(float(row[17]),float(row[16]))], 
                                    description = 'MEO Solution \nBeacon = ' + str(row[2]) + '\n' 
                                    '\nLat,Long = {0:.4f}'.format(float(row[16])) + ',{0:.4f}'.format(float(row[17])) +
                                    '\nAddTime = ' + str(row[8]) + '\nAlertSiteSolId = ' + str(int(row[0])) +
                                    '\nAlertMsgName = ' + str(row[21]) + '\n\nSource = ' + str(row[10]) + 
                                    '\nNumBursts = ' + str(int(row[12])) + '\nNumPackets = ' + str(int(row[13])) +
                                    '\nNumSats = ' + str(int(row[14])) + '\nDOP = ' + str(row[15]) + 
                                    '\nEHE = ' + str(row[22])
                                    )
                                pnt_RCC.style.iconstyle.icon.href = '/static/icons/iconM'
                                pnt_RCC.style.iconstyle.scale = 0.5
                            elif row[18] :
                                pnt_RCC = fol_RCC.newpoint(coords=[(float(row[19]),float(row[18]))], 
                                    description = 'LEO Solution \nBeacon = ' + str(row[2]) + '\n' 
                                    '\nLat,Long = {0:.4f}'.format(float(row[18])) + ',{0:.4f}'.format(float(row[19])) +
                                    '\nAddTime = ' + str(row[8]) + '\nAlertSiteSolId = ' + str(int(row[0])) +
                                    '\nAlertMsgName = ' + str(row[21]) + '\n\nSource = ' + str(row[10]) + 
                                    '\nSat = ' + str(row[23]) + '\nTCA = ' + str(row[24])
                                    )
                                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon43.png'
                                pnt_RCC.style.iconstyle.scale = 0.8
                            pnt_RCC.timespan.begin = str(row[8])[:10] + 'T' + str(row[8])[11:19]
                            pnt_RCC.style.labelstyle.color = 'FFFFFF'              
            kml.save(os.path.join(approot,KMLfile))
    return insols, KMLfile

def outsol_query(sitenum, OUTPUTFOLDER, approot, servername = 'localhost', databasename = 'MccTestLGM', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    c = conn.cursor()
    params = [sitenum]
    sql_query = (' '
        #'declare @bcnid as varchar(15) '
        #'declare @bcnid2 as varchar(17) '
        #'set @bcnid= ? '
        #'set @bcnid2= "%" + @bcnid + "%" '
        'SELECT b.AddTime, b.AlertSiteSolId, b.TimeFirst, b.TimeLast, b.Tca, a.MsgName, '
        'b.SolReal, b.EncReal, b.AlertMsgState, c.ComSiteName, c.DestMcc, '
        'b.PrevSarNameList, b.CurSarNameList, b.SourceId,b.SourceId2, b.EncLat, '
        'b.EncLon, b.Latitude, b.Longitude, b.A_Lat, b.A_Lon, b.B_Lat, b.B_Lon, '
        'a.TableName, a.InMsgId, b.SourceNameRccMsg, b.BcnId15, b.RegBcnId15, '
        'b.SatelliteIds, b.Sat, c.SitNum, b.ASiteDuration  '
        'FROM OutputMessage a, OutSolution b, OutputProcess c '
        'WHERE '
        'b.alertsitenum = ? '
        'AND (b.OutMsgId=a.OutMsgId AND c.OutMsgId=a.OutMsgId) '
        'order by addtime '                 
        )
    c.execute(sql_query, params)
    outsols = c.fetchall()
    KMLfile = False
    if "makeKML" in kwargs:
        if kwargs.get("makeKML"):
            KMLfile = os.path.join(OUTPUTFOLDER, 'KML_RCC_site_' + sitenum +'.kml')
            kml = simplekml.Kml()
            fol_RCC = kml.newfolder(name='RCC Output Locations')
            for row in outsols:
                if ((row[17] is not None) and (row[17] <> 'NULL')) or ((row[19] is not None) and (row[19] <> 'NULL')):
                    if (row[17] is not None) and (row[17] <> 'NULL'):
                        pnt_RCC = fol_RCC.newpoint(coords=[(float(row[18]),float(row[17]))], 
                            description = 'RCC Solution \nBeacon = ' + str(row[26]) + '\n' 
                            '\nLat,Long = {0:.4f}'.format(float(row[17])) + ',{0:.4f}'.format(float(row[18])) +
                            '\nAddTime = ' + str(row[0]) + '\nAlertSiteSolId = ' + str(int(row[1])) +
                            '\nMsgName = ' + str(row[5]) + '\n\nLUT = ' + str(int(row[13])) + '\nSats = ' + str(row[28])
                            )
                    if (row[19] is not None) and (row[19] <> 'NULL'):
                        print row[19]
                        pnt_RCC = fol_RCC.newpoint(coords=[(float(row[20]),float(row[19]))], 
                            description = 'RCC Solution \nBeacon = ' + str(row[26]) + '\n' 
                            '\nLat,Long = {0:.4f}'.format(float(row[19])) + ',{0:.4f}'.format(float(row[20])) +
                            '\nAddTime = ' + str(row[0]) + '\nAlertSiteSolId = ' + str(int(row[1])) +
                            '\nMsgName = ' + str(row[5]) + '\n\nLUT = ' + str(int(row[13])) + '\nSat = ' + str(row[29]) 
                            )
                    pnt_RCC.timespan.begin = str(row[0])[:10] + 'T' + str(row[0])[11:19]
                    pnt_RCC.style.iconstyle.scale = 0.9
                    pnt_RCC.style.labelstyle.color = 'FFFFFF'  
                    if row[5] == 'MEOFirstAlertDOA':
                        pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
                    elif row[5] == '406BlownCompDoppler':
                        pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon63.png'
                    elif row[5] == 'MEOBlownCompDOA':
                        pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon63.png'
                    elif row[5] == 'MEONocrDOA':
                        pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
                    elif row[5] == 'MEOUpdatedNoCompDOA':
                        pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
                    elif row[5] == 'MEOUpdatedCompDOA':
                        pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
                    elif row[5] == '406UpdatedCompDoppler':
                        pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
                    else:
                        pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon43.png'

               
            kml.save(os.path.join(approot,KMLfile))
    return outsols, KMLfile

def both_kml(sitenum, OUTPUTFOLDER, approot, servername = 'localhost', databasename = 'MccTestLGM', **kwargs):
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    c = conn.cursor()
    params = [sitenum]
    sql_query = (' '
        #'declare @bcnid as varchar(15) '
        #'declare @bcnid2 as varchar(17) '
        #'set @bcnid= ? '
        #'set @bcnid2= "%" + @bcnid + "%" '
        'SELECT b.AddTime, b.AlertSiteSolId, b.TimeFirst, b.TimeLast, b.Tca, a.MsgName, '
        'b.SolReal, b.EncReal, b.AlertMsgState, c.ComSiteName, c.DestMcc, '
        'b.PrevSarNameList, b.CurSarNameList, b.SourceId,b.SourceId2, b.EncLat, '
        'b.EncLon, b.Latitude, b.Longitude, b.A_Lat, b.A_Lon, b.B_Lat, b.B_Lon, '
        'a.TableName, a.InMsgId, b.SourceNameRccMsg, b.BcnId15, b.RegBcnId15, '
        'b.SatelliteIds, b.Sat, c.SitNum, b.ASiteDuration  '
        'FROM OutputMessage a, OutSolution b, OutputProcess c '
        'WHERE '
        'b.alertsitenum = ? '
        'AND (b.OutMsgId=a.OutMsgId AND c.OutMsgId=a.OutMsgId) '
        'order by addtime '                 
        )
    c.execute(sql_query, params)
    outsols = c.fetchall()
    KMLfile = False
    KMLfile = os.path.join(OUTPUTFOLDER, 'KML_site_' + sitenum +'.kml')
    Mapfile = os.path.join('/MapTest?KML=' + KMLfile).replace("\\","/")
    kml = simplekml.Kml()
    fol_RCC = kml.newfolder(name='RCC Output Locations')
    for row in outsols:

        if ((row[17] is not None) and (row[17] <> 'NULL')) or ((row[19] is not None) and (row[19] <> 'NULL')):
            if (row[17] is not None) and (row[17] <> 'NULL'):
                pnt_RCC = fol_RCC.newpoint(coords=[(float(row[18]),float(row[17]))], 
                    description = 'RCC Solution \nBeacon = ' + str(row[26]) + '\n' 
                    '\nLat,Long = {0:.4f}'.format(float(row[17])) + ',{0:.4f}'.format(float(row[18])) +
                    '\nAddTime = ' + str(row[0]) + '\nAlertSiteSolId = ' + str(int(row[1])) +
                    '\nMsgName = ' + str(row[5]) + '\n\nLUT = ' + str(int(row[13])) + '\nSats = ' + str(row[28])
                    )
            if (row[19] is not None) and (row[19] <> 'NULL'):
                print row[19]
                pnt_RCC = fol_RCC.newpoint(coords=[(float(row[20]),float(row[19]))], 
                    description = 'RCC Solution \nBeacon = ' + str(row[26]) + '\n' 
                    '\nLat,Long = {0:.4f}'.format(float(row[19])) + ',{0:.4f}'.format(float(row[20])) +
                    '\nAddTime = ' + str(row[0]) + '\nAlertSiteSolId = ' + str(int(row[1])) +
                    '\nMsgName = ' + str(row[5]) + '\n\nLUT = ' + str(int(row[13])) + '\nSat = ' + str(row[29]) 
                    )
            pnt_RCC.timespan.begin = str(row[0])[:10] + 'T' + str(row[0])[11:19]
            pnt_RCC.style.iconstyle.scale = 0.9
            pnt_RCC.style.labelstyle.color = 'FFFFFF'  
            if row[5] == 'MEOFirstAlertDOA':
                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
            elif row[5] == '406BlownCompDoppler':
                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
            elif row[5] == 'MEOBlownCompDOA':
                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
            elif row[5] == 'MEONocrDOA':
                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
            elif row[5] == 'MEOUpdatedNoCompDOA':
                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
            elif row[5] == 'MEOUpdatedCompDOA':
                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
            elif row[5] == '406UpdatedCompDoppler':
                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon57.png'
            else:
                pnt_RCC.style.iconstyle.icon.href = '/static/icons/icon43.png'

    ## Now get MEOLUT input 
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)
    c = conn.cursor()
    params = [sitenum]
    sql_query = ('select alertsitesolid, inputdatatype, bcnid15, framesync, '
        'complat, complon, sitfunc, gentime, addtime, sourceid, sourcename, '
        'sourcemccname, numbursts, numpackets, numsatellites, dop, latitude, '
        'longitude, a_lat, a_lon, MatchDistance, AlertMsgState, ExpectedHorzError, Sat, Tca '
        'from AlertSiteSol where '
        'AlertSiteNum = ? '
        'order by gentime '
        )
    c.execute(sql_query, params)
    insols = c.fetchall()
    fol_MEO = kml.newfolder(name='Input Locations')
    for row in insols:  
                if ((row[16] is not None) and (row[16] <> 'NULL')) or ((row[18] is not None) and (row[18] <> 'NULL')):
                    if ((row[16] is not None) and (row[16] <> 'NULL')):
                        pnt_MEO = fol_MEO.newpoint(coords=[(float(row[17]),float(row[16]))], 
                            description = 'MEO Solution \nBeacon = ' + str(row[2]) + '\n' 
                            '\nLat,Long = {0:.4f}'.format(float(row[16])) + ',{0:.4f}'.format(float(row[17])) +
                            '\nAddTime = ' + str(row[8]) + '\nAlertSiteSolId = ' + str(int(row[0])) +
                            '\nAlertMsgName = ' + str(row[21]) + '\n\nSource = ' + str(row[10]) + 
                            '\nNumBursts = ' + str(int(row[12])) + '\nNumPackets = ' + str(int(row[13])) +
                            '\nNumSats = ' + str(int(row[14])) + '\nDOP = ' + str(row[15]) + 
                            '\nEHE = ' + str(row[22])
                            )
                        pnt_MEO.style.iconstyle.icon.href = '/static/icons/iconM.png'
                        pnt_MEO.style.iconstyle.scale = 0.5
                    elif ((row[18] is not None) and (row[18] <> 'NULL')):
                        pnt_MEO = fol_MEO.newpoint(coords=[(float(row[19]),float(row[18]))], 
                            description = 'LEO Solution \nBeacon = ' + str(row[2]) + '\n' 
                            '\nLat,Long = {0:.4f}'.format(float(row[18])) + ',{0:.4f}'.format(float(row[19])) +
                            '\nAddTime = ' + str(row[8]) + '\nAlertSiteSolId = ' + str(int(row[0])) +
                            '\nAlertMsgName = ' + str(row[21]) + '\n\nSource = ' + str(row[10]) + 
                            '\nSat = ' + str(row[23]) + '\nTCA = ' + str(row[24])
                            )
                        pnt_MEO.style.iconstyle.icon.href = '/static/icons/icon43.png'
                        pnt_MEO.style.iconstyle.scale = 0.8
                    pnt_MEO.timespan.begin = str(row[8])[:10] + 'T' + str(row[8])[11:19]
                    pnt_MEO.style.labelstyle.color = 'FFFFFF'                          
    kml.save(os.path.join(approot,KMLfile))
    return KMLfile, Mapfile
def MSSQL_beacon_analysis(result, TimeStart, TimeEnd, OUTPUTFOLDER, approot, servername = 'localhost', databasename='mccoperational', gt_file = False, Lat_GT=0, Long_GT=0, Location='', **kwargs):
    filetimetag = datetime.strftime(datetime.utcnow(),"%Y%m%d_%H%M%S")
    filelist = OrderedDict()
    imglist = []
    if 'sql_login' in kwargs:
        conn = pypyodbc.connect(r'Driver={FreeTDS};Server='+servername+';Database='+databasename+'; UID='+UID+'; PWD=' + PWD)
    else:
        conn = pypyodbc.connect(r'Driver={SQL Server};Server='+servername+';Database='+databasename+';Trusted_Connection=yes;',readonly=True)

    MEOList = []
    if 'MEOLUT_HI' in result: MEOList.append(3385)
    if 'MEOLUT_FL' in result: MEOList.append(3669)
    if 'MEOLUT_FR' in result: MEOList.append(2276)

    BeaconQuery, BeaconID, Lat_GT, Long_GT, Location, MEO_dist = parse_results(result,MEOList)
    print BeaconQuery, BeaconID, Lat_GT, Long_GT, Location, MEO_dist 
    
    ### Define a whole bunch of subfunctions that might be used in this function

    #Generate stats on a df (<5km, 10, 20 , median, quintiles)  
    ''' Returns a tuple of total num solutions in df, # within dist_list[0], % within dist_list[0], etc, 
    median, number of burst within quintile[0], etc.  
    then mean and 95%
    '''
    def stats(df,dist_list, q_list):
        distout = []
        perout = []
        outlist = []
        totnum = df.shape[0]
        outlist.append(totnum)
        ave = round(df[errorname].mean(),2)
        median = round(df[errorname].quantile(.5),2)
        win_5km = round(safe_div(df[df[errorname]<5].shape[0],totnum),2)
        win_10km = round(safe_div(df[df[errorname]<10].shape[0],totnum),2)
        q95 = round(df[errorname].quantile(.95),2)
        outlist.append(ave)
        for dist in dist_list:
            distout.append(df[df[errorname]<dist].shape[0])
            perout.append(round(safe_div(df[df[errorname]<dist].shape[0],totnum),2))
        distlistout = [val for pair in zip(distout, perout) for val in pair] #interleaves two lists of same length
        outlist.extend(distlistout)
        qout = df[errorname].quantile(q_list)
        qout = [round(q,2) for q in qout]

        outlist.extend(qout)
        return outlist, ave, median,  q95, win_5km, win_10km

    #Return dataframe where a certain satellite is used
    def sat_find(df, sat):
        dfsat = df[df[satidsname].str.contains(sat)]
        return dfsat

    def get_cmap(n, name='brg'):
        '''Returns a function that maps each index in 0, 1, ..., n-1 to a distinct 
        RGB color; the keyword argument name must be a standard mpl colormap name.'''
        return plt.cm.get_cmap(name, n)

    def hist_cum_plot(df,list1,maxrange,title, textstr,legendhandles,textstr2, **args):
        bin_range = np.arange(0, maxrange+2)
        dfall = np.clip(df[errorname],bin_range[0],bin_range[-1])
        count, division = np.histogram(dfall, bins = bin_range)
        ax1 = dfall.hist(bins=division, stacked = True, color = 'grey')
        ax1.set_ylabel('Number of Locations Produced')
        ax1.set_xlabel('Location Error (km)')
        cumulative = np.cumsum(count).astype(np.float64)
        x = np.linspace(0,bin_range[-1],cumulative.size)
        cumulative/=cumulative.max()
        cumulative*=100.
        ax2 = ax1.twinx()
        ax2.set_ylabel('Cumulative Error (%)')
        props = dict(boxstyle='round', facecolor='wheat', alpha=0.3)
        props2 = dict(boxstyle='round', facecolor='white', alpha=0.3)
        ax2.text(bin_range.mean(), 30, textstr, fontsize=10,
            verticalalignment='bottom', bbox = props)
        if textstr2:
            ax2.text(bin_range.mean(), 70, textstr2, fontsize=10,
                verticalalignment='center', bbox = props2)
        plt.plot(x,cumulative,'o-', color = 'black')
        cmap = get_cmap(len(list1))
        plotdf = []
    
        # Loop below builds the cumulative error plots and arrays for stacked histogram
        for i, df1 in enumerate(list1):
            df2 = np.clip(df1[errorname],bin_range[0],bin_range[-1])
            plotdf.append(df2)
            count, division = np.histogram(df2, bins = bin_range)
            cumulative = np.cumsum(count).astype(np.float64)
            x = np.linspace(0,bin_range[-1],cumulative.size)
            cumulative/=cumulative.max()
            cumulative*=100.
            plt.plot(x,cumulative, color=cmap(i), linestyle='dashed', linewidth=2)
            ax2.legend(legendhandles, fontsize = 10, loc = 'right')

        # This builds the df for stacked histogram and color list
        plotlist = []
        colors = []
        for i, df4 in enumerate(plotdf):
            plotlist.append(df4)
            colors.append(cmap(i))
        ax1.hist(plotlist, division, histtype='bar', stacked = True, color=colors, rwidth=0.85, alpha = 0.65)
        plt.title(title, fontsize = 14)
        ax1.set_xlim([bin_range[0],bin_range[-1]])
        ax2.set_ylim([0,100])
        #if plotmean: plt.axvline(df[errorname].mean(), color='gray', linestyle='dashed', linewidth=1)
        #if plotmedian: plt.axvline(df[errorname].median(), color='gray', linestyle='dashed', linewidth=1)
        return plt


    
    ''' Define the column names for data below'''

    UseMCC = True
    if result.get('UseBeaconID') == 'SiteInput':
        bcn_or_site = 'Site'
        Sitenum = result.get('siteID')
        print 'site = ' + Sitenum
    else:
        bcn_or_site = 'Beacon'
    dist = [5, 10, 20]
    q = [0.5, .75, .9, .95]
    errorname = 'Error_GT'

    fieldname = OrderedDict()
    if UseMCC:
        fieldname['datatypename'] = 'datatype'
        fieldname['bcn15name'] = 'bcnid15'
        fieldname['bcn30name'] = 'bcnid30'
        fieldname['sourceidname'] = 'sourceid'
        fieldname['timefirstname'] = 'timefirst'
        fieldname['timelastname'] = 'timelast'
        fieldname['latname'] = 'latitude'
        fieldname['lonname'] = 'longitude'
        fieldname['altname'] = 'altitude'
        fieldname['numburstsname'] = 'numbursts'
        fieldname['numpacketsname'] = 'numpackets'
        fieldname['numsatsname'] = 'numsatellites'
        fieldname['dopname'] = 'dop'
        fieldname['cn0name'] = 'averagecn0'
        fieldname['ehename'] = 'expectedhorzerror'
        fieldname['satidsname'] = 'satelliteids'
       

    else:
        datatypename = 'dataUsed'
        errorname = 'locError_km'
        errorname = 'Error'
        numsatsname = 'nbSat'
        numburstsname = 'nbBursts'
        satidsname = 'listSatID'

    fieldlist = []
    for key, value in fieldname.iteritems():
        fieldlist.append(value)
    sql_query_field_list = ", ".join(fieldlist)
    
    if bcn_or_site == 'Site':
        sql_query = ('declare @bcnid varchar(16) = ( '
	                 'select top 1 [BcnId15] From AlertSiteSum where '
	                 'AlertSiteNum = ? '
                     'AND '
                     'TimeFirst between ? AND ? '
                     'ORDER BY TimeLast '
                     ') '
	                 'SELECT ' + sql_query_field_list + ' FROM '
                     'InputMEOSolution '
                     'WHERE '
                     'BcnId15 = @bcnid '
                     )
        params=[Sitenum, TimeStart, TimeEnd]
    else:
        sql_query = ('SELECT ' + sql_query_field_list + ' FROM '
                     'InputMEOSolution ' 
                     'WHERE ' 
                     'TimeSolutionGenerated between ? AND ? '
                     'AND '
                     'BcnId15 LIKE ? '
                     )
        params=[TimeStart, TimeEnd, BeaconQuery]
    df = pd.read_sql_query(sql_query,conn, params= params) #, index_col = 'timesolutionadded', params=params)
    #    parse_dates=['timefirst','timelast', 'timesolutiongenerated','timesolutionadded'])
    #df = pd.DataFrame(cursor.fetchall())
    #print df.head(5)
    #df.columns = pd.DataFrame(np.matrix(cursor.description))[0]
    df_data = []
    for MEO in MEOList:
        df_data.append(filter1(df,'sourceid',MEO))
    dfMEO = pd.concat(df_data)
    df_filter = filter1(dfMEO,fieldname['datatypename'],0)

    filterlist = []
    if result.get('filter1check',False):
        if result.get('filter1sel') == 'filter1ran':
            df_filter =  filter_range(df_filter, fieldname[result.get('filter1')], result.get('filter1rangelow',0), result.get('filter1rangehigh',100))
            filterlist.append(fieldname[result.get('filter1')] + ' between ' + result.get('filter1rangelow',0) + ' and ' + result.get('filter1rangehigh',100))
        else:
            df_filter = filter1(df_filter, fieldname[result.get('filter1')], result.get('filter1value',0))
            filterlist.append(fieldname[result.get('filter1')] + ' = ' + result.get('filter1value',0))
    if result.get('filter2check',False):
        if result.get('filter2sel') == 'filter2ran':
            df_filter =  filter_range(df_filter, fieldname[result.get('filter2')], result.get('filter2rangelow',0), result.get('filter2rangehigh',100))
            filterlist.append(fieldname[result.get('filter2')] + ' between ' + result.get('filter2rangelow',0) + ' and ' + result.get('filter2rangehigh',100))
        else:
            df_filter = filter1(df_filter, fieldname[result.get('filter2')], result.get('filter2value',0))
            filterlist.append(fieldname[result.get('filter2')] + ' = ' + result.get('filter2value',0))
    if result.get('filter3check',False):
        if result.get('filter3sel') == 'filter3ran':
            df_filter =  filter_range(df_filter, fieldname[result.get('filter3')], result.get('filter3rangelow',0), result.get('filter3rangehigh',100))
            filterlist.append(fieldname[result.get('filter3')] + ' between ' + result.get('filter3rangelow',0) + ' and ' + result.get('filter3rangehigh',100))
        else:
            df_filter = filter1(df_filter, fieldname[result.get('filter3')], result.get('filter3value',0))
            filterlist.append(fieldname[result.get('filter3')] + ' = ' + result.get('filter3value',0))
    if df_filter.empty: 
        print 'no data ' 
        return None, None, None
    
    #dfout = sat_find(dfout1,'330') ### Need to implement sat find
    
    # Fill in encoded locations
    lat_fun = lambda hexin: bcn.beacon(hexin).lat
    lon_fun = lambda hexin: bcn.beacon(hexin).lon
    df_filter['Enc_Lat'] = df_filter['bcnid30'].apply(lat_fun)
    df_filter['Enc_Lon'] = df_filter['bcnid30'].apply(lon_fun)
    if gt_file:
        df_gt = pd.read_csv(gt_file, index_col = 'time', parse_dates = ['time']) 
        # add ability to read excel files 


        gt_starttime = df_gt.index.min()
        gt_endtime = df_gt.index.max()
        sol_starttime = df_filter[fieldname['timefirstname']].min()
        sol_endtime = df_filter[fieldname['timelastname']].max()
        if result.get('KMLgen'):
            kml = simplekml.Kml()
            GT_fol = kml.newfolder(name='GT Locations')
            #print len(GT_fol)
            for row in df_gt.itertuples():
                GT_point = GT_fol.newpoint(
                name= 'GT - ' + str(row[0]),
                coords=[(float(row[2]),float(row[1]))]
                )
                print str(row[0])
                GT_point.timespan.begin = str(row[0])[:10] + 'T' + str(row[0])[11:19]
                #GT_point.style.iconstyle.icon.href = 'static/icons/blue_pog.png'
                GT_point.style.iconstyle.icon.href = 'http://maps.google.com/mapfiles/kml/shapes/road_shield1.png'
                GT_point.style.labelstyle.scale = 0 
                GT_point.style.iconstyle.scale = 0.7 
        def get_lat_lon_time(df,dateandtime):
            if dateandtime not in df.index:
                newrow = pd.DataFrame(data = [np.nan], index = [dateandtime])
                df = df.append(newrow)
            LON = pd.Series(index=df.index, data= df.lon.values).sort_index().interpolate(method='time')[dateandtime]
            LAT = pd.Series(index=df.index, data= df.lat.values).sort_index().interpolate(method='time')[dateandtime]
            return LAT, LON, dateandtime

        for index, row in df_filter.iterrows():
            lat, lon, timeat = get_lat_lon_time(df_gt,row['timelast'])
            df_filter.set_value(index,'Lat_GT', lat)
            df_filter.set_value(index,'Lon_GT', lon)
            #df_filter.set_value(index,'Time_GT', timeat)



        df_filter['Error_GT'] = df_filter[['Lat_GT','Lon_GT','latitude','longitude']].apply(haversine, axis = 1)
        if 'Enc_Lat' in df_filter.columns: 
            df_filter['Error_Enc'] = df_filter[['Lat_GT','Lon_GT','Enc_Lat','Enc_Lon']].apply(haversine, axis = 1)
  


    if (Lat_GT is not None) and (Long_GT is not None):
        df_filter['Lat_GT'],df_filter['Lon_GT'] = Lat_GT, Long_GT
        df_filter['Error_GT'] = df_filter[['latitude','longitude', 'Lat_GT','Lon_GT']].apply(haversine, axis = 1)

    df_filter['Error_Enc'] = df_filter[['latitude','longitude','Enc_Lat','Enc_Lon']].apply(haversine, axis = 1)
    
    
    ### still need to add column for location error here

    # Need to write sols to file 
    if result.get('SolutionsOut',False) or result.get('KMLgen',False):
        Solutionfilename = os.path.normpath(os.path.join(OUTPUTFOLDER, filetimetag + '_Solutions.csv'))
        df_filter.to_csv(os.path.join(approot,Solutionfilename))
        filelist[Solutionfilename] = 'Solutions file'

    statsout, mean, median, q95, win_5km, win_10km = stats(df_filter,dist,q)

    ### This is for generating plots
    if result.get('histcum',False):
        textstr1 = 'Total Stats \n\nNum Locations = %.d\nmean = %.1f km\nmedian = %.1f km\n95%% = %.1f km\n\n%% within 5 km = %.1f%%\n%% within 10 km = %.1f%%'%(statsout[0], mean, median,  q95, 100*win_5km, 100*win_10km)# ' % (statsout[0])#\nmean=%.2f$\nmedian=%.2f$\n95=%.2f'%(statsout[0], mean, median, q95)
        legendhandles = ['all']

        dflist = []
        titleheader = []
        titlelist = []
        filtertext = None
        #Generate text box for filters
        if len(filterlist) > 0: 
            filtertextlist = ['Filters \n']
            for item in filterlist:
                filtertextlist.append(item)
            filtertext = '\n'.join(filtertextlist)
        
        if result.get('Location'): 
            titleheader.append(result.get('Location'))
        if (result.get('beaconLat') and result.get('beaconLon')): 
            titleheader.append('(' + result.get('beaconLat') + ', ' +result.get('beaconLon')+')')
        titlelist.append(' '.join(titleheader))
        MEOListstring = []
        for MEO in MEOList:
            MEOListstring.append(str(MEO))

        titlelist.append(' '.join(MEOListstring))

        #Need to get the field to vary and set it below
        if result.get('plotvary'):
            varyfield = fieldname[result.get('plotvaryby')]
            titlelist.append('Varying ' + varyfield)
            if varyfield == 'numsatellites':
                satrangediff = 1
                satrange = range(3,11,satrangediff) # could be variable          
                for i in satrange:
                    if i == satrange[-1]:
                        dflist.append(filter_range(df_filter,varyfield,i,20))
                        legendhandles.append(varyfield + ': ' + str(i) + '+ ')
                    else:
                        dflist.append(filter1(df_filter,varyfield,i))
                        legendhandles.append(varyfield + ': ' + str(i))
            if varyfield == 'dop':
                doprangediff = 1
                doprange = range(0,7,doprangediff) # could be variable 
                for i in doprange:
                    if i == doprange[-1]:
                        dflist.append(filter_range(df_filter,varyfield,i,100))
                        legendhandles.append(varyfield + ': ' + str(i) + '+ ')
                    else:
                        dflist.append(filter_range(df_filter,varyfield,i,i+doprangediff))
                        legendhandles.append(varyfield + ': ' + str(i) + ' - ' + str(i+doprangediff))
            if varyfield == 'expectedhorzerror':
                eherangediff = 2
                eherange = range(0,10,eherangediff) # could be variable 
                for i in eherange:
                    if i == eherange[-1]:
                        dflist.append(filter_range(df_filter,varyfield,i,100))
                        legendhandles.append(varyfield + ': ' + str(i) + '+ ')
                    else:
                        dflist.append(filter_range(df_filter,varyfield,i,i+eherangediff))
                        legendhandles.append(varyfield + ': ' + str(i) + ' - ' + str(i+eherangediff))
            if varyfield == 'numbursts':
                numburstrangediff = 3
                numburstrange = [1, 2]
                numburstrange.extend(range(3,30,numburstrangediff)) # could be variable 
                for i in numburstrange:
                    if i == 1 or i == 2:
                        dflist.append(filter1(df_filter,varyfield,i))
                        legendhandles.append(varyfield + ': ' + str(i) )                    
                    elif i == numburstrange[-1]:
                        dflist.append(filter_range(df_filter,varyfield,i,100))
                        legendhandles.append(varyfield + ': ' + str(i) + '+ ')
                    else:
                        dflist.append(filter_range(df_filter,varyfield,i,i+numburstrangediff))
                        legendhandles.append(varyfield + ': ' + str(i) + ' - ' + str(i+numburstrangediff))
            if varyfield == 'numpackets':
                numpacketsrangediff = 10
                numpacketsrange = range(0,100,numpacketsrangediff) # could be variable 
                for i in numpacketsrange:
                    if i == numpacketsrange[-1]:
                        dflist.append(filter_range(df_filter,varyfield,i,200))
                        legendhandles.append(varyfield + ': ' + str(i) + '+ ')
                    else:
                        dflist.append(filter_range(df_filter,varyfield,i,i+numpacketsrangediff))
                        legendhandles.append(varyfield + ': ' + str(i) + ' - ' + str(i+numpacketsrangediff))
            if varyfield == 'averagecn0':
                cn0rangediff = 2
                cn0range = range(30,50,cn0rangediff) # could be variable 
                for i in cn0range:
                    if i == cn0range[-1]:
                        dflist.append(filter_range(df_filter,varyfield,i,100))
                        legendhandles.append(varyfield + ': ' + str(i) + '+ ')
                    else:
                        dflist.append(filter_range(df_filter,varyfield,i,i+cn0rangediff))
                        legendhandles.append(varyfield + ': ' + str(i) + ' - ' + str(i+cn0rangediff))


        title = "\n".join(titlelist)
        # range needs to be chosen correct for what field is varying - currently good for numsats 

        plt1 = plt.figure(figsize=(16, 9), dpi=400, facecolor='w', edgecolor='k')
        plt1 = hist_cum_plot(df_filter,dflist,50,title, textstr1,legendhandles, filtertext) 

        filename = os.path.normpath(os.path.join(OUTPUTFOLDER, filetimetag + '_histogram.png'))
        imglist.append(filename)
        plt1.savefig(os.path.join(approot, filename)) #, bbox_inches='tight')
        plt.clf()
        plt.cla()
        plt.close('all')
    statsfile = os.path.normpath(os.path.join(OUTPUTFOLDER, filetimetag + '_out_stats_sum.csv'))
    rw = []
    rw.extend(statsout)
    
    headerlist = []
    statslist = []
    headerlist.append(bcn_or_site)
    if bcn_or_site == 'Site':
        statslist.append(Sitenum)
    else:
        statslist.append(BeaconID)
    if result.get('Location'): 
        headerlist.append('Location')
        statslist.append(result.get('Location'))
    if (result.get('beaconLat') and result.get('beaconLon')): 
        headerlist.append('BeaconLat')
        headerlist.append('BeaconLon')
        statslist.append(result.get('beaconLat'))
        statslist.append(result.get('beaconLon'))

    MEOListstring = []
    for i, MEO in enumerate(MEOList):
        headerlist.append('MEO-' + str(i+1))
        statslist.append(str(MEO))
        headerlist.append('MEO-' + str(i+1) + ' dist (km)')
        if MEO_dist[i] <> None: 
            statslist.append(str(round(MEO_dist[i],1)))
        else:
            statslist.append('NA')
    
    for i, filter in enumerate(filterlist):
        headerlist.append('Filter-' + str(i+1))
        statslist.append(filter)


    #headrow = [','.join(headerlist)]
    headrow = []
    
    headrow2 = ['# locations','ave','# <5 km','% < 5 km','# < 10 km','% < 10 km','# < 20 km','% < 20 km','median (km)','75% (km)','90% (km)','95% (km)']
    headrow.extend(headerlist)
    headrow.extend(headrow2)

    statsrow = []
    statsrow.extend(statslist)
    statsrow.extend(rw)

    with open(os.path.join(approot, statsfile), 'a') as csvfile:
        csvwriter = csv.writer(csvfile, delimiter=',')
        csvwriter.writerow(headrow)
        csvwriter.writerow(statsrow)


    

    if result.get('KMLgen'): 
        KMLfile = os.path.join(OUTPUTFOLDER, 'KML' + filetimetag +'.kml')
        Mapfile = os.path.join('/MapTest?KML=' + KMLfile).replace("\\","/")
        filelist[KMLfile] = 'KML File Output'
        filelist[Mapfile] = 'MapIt'
        if not gt_file: kml = simplekml.Kml()
        if result.get('beaconLat') <> '':
            firstrad = 5000
            secondrad = 10000
            folEnc = kml.newfolder(name = 'Ground Truth ')                
            polycircle1 = polycircles.Polycircle(latitude=Lat_GT,
                                    longitude=Long_GT,
                                    radius=firstrad,
                                    number_of_vertices=36)            
            pol1 = kml.newpolygon(name="5km",
                                         outerboundaryis=polycircle1.to_kml())
            pol1.style.polystyle.color = \
                simplekml.Color.changealphaint(100, simplekml.Color.green)
            # Second region

            polycircle2outer = polycircles.Polycircle(latitude=Lat_GT,
                                    longitude=Long_GT,
                                    radius=secondrad,
                                    number_of_vertices=36)            

            pol2 = kml.newpolygon(name="10km",
                                         outerboundaryis=polycircle2outer.to_kml(),
                                         innerboundaryis = polycircle1.to_kml())
            pol2.style.polystyle.color = \
                simplekml.Color.changealphaint(100, simplekml.Color.yellow)
            pntEnc = folEnc.newpoint(
                name = 'Ground Truth',
                coords=[(Long_GT,Lat_GT)], 
                description = 'Lat,Long = (' + str(Lat_GT) + ', ' + str(Long_GT) + ')'  
                )
            pntEnc.style.iconstyle.icon.href = '/static/icons/arrow.png'
            pntEnc.style.iconstyle.scale = 0.8
            pntEnc.style.labelstyle.color = '00ff0000'  # Red

        with open(os.path.join(approot,Solutionfilename), 'rb') as csvfile:
            csvfile.next()
            filereader = csv.reader(csvfile)
            folEnc = kml.newfolder(name = 'Encoded Locations')                
            for row in filereader:
                if (row[17] <> 'NULL') and (row[17] is not None) and (row[17] <> ''):  
                    pntEnc = folEnc.newpoint(
                        name= row[6],
                        coords=[(float(row[18]),float(row[17]))], 
                        description = 'Encoded Location - Beacon = ' + row[2] + '\nTimeLast = ' + 
                    row[6] + '\nLat,Long = (' + row[17] + ', ' +row[18] + ')'  
                        )
                    pntEnc.timespan.begin = row[6][:10] + 'T' + row[6][11:19]
                    pntEnc.style.iconstyle.icon.href = '/static/icons/track-none.png'
                    pntEnc.style.iconstyle.scale = 0.8
                    pntEnc.style.labelstyle.color = '00ff0000'  # Red
                    pntEnc.style.labelstyle.scale = 0 
        with open(os.path.join(approot,Solutionfilename), 'rb') as csvfile:
            csvfile.next()
            filereader = csv.reader(csvfile)
            folMBL = kml.newfolder(name='MEOLUT Locations')
            for row in filereader:            
                try: 
                    GT_error = '{0:.2f}'.format(float(row[21]))
                except: 
                    GT_error = 'NA' 
                try: 
                    Enc_error = '{0:.2f}'.format(float(row[22]))
                except: 
                    Enc_error = 'NA' 
                
                pntMBL = folMBL.newpoint(
                    name=row[6],
                    coords=[(float(row[8]),float(row[7]),float(row[9]))], 
                    description = 'Multi Burst Location - Beacon = ' + row[2] + '\nLat,Long,Alt = ' + row[7] + 
                    ', ' + row[8] + ', ' + row[9] + '\nTimeLast = ' + row[6] + '\nTimeFirst = ' + 
                    row[5] + '\nMEOLUT = ' + row[4] + '\nGT_Error = ' + GT_error + 
                    '\nEnc_Error = '+ Enc_error +  
                    '\nNum of Bursts = ' + row[10] + '\nNum of Packets = ' +row[11] +'\nNum Sats = ' + row[12] + 
                    '\nDOP = ' +row[13] + '\nAveCN0 = ' +row[14] + '\nEHE = ' + row[15] + '\nSats-' + row[16]

                    )
                pntMBL.timespan.begin = row[6][:10] + 'T' + row[6][11:19]
                pntMBL.style.iconstyle.icon.href = '/static/icons/icon49.png'
                pntMBL.style.iconstyle.scale = 0.8 
                pntMBL.style.labelstyle.color = 'ff0000ff'  # Red
                pntMBL.style.labelstyle.scale = 0  

                if (result.get('ErrorLines') and (GT_error != 'NA')):
                    GT_errorline = GT_fol.newlinestring(name='Error - ' + row[6])
                    GT_errorline.coords = [(float(row[8]),float(row[7]),float(row[9])),(float(row[20]), float(row[19]), 0)]
                    print str(row[6])
                    GT_errorline.timespan.begin = str(row[6])[:10] + 'T' + str(row[6])[11:19]
                    GT_errorline.style.iconstyle.icon.href = 'http://maps.google.com/mapfiles/kml/shapes/road_shield3.png'
                    GT_errorline.style.labelstyle.scale = 0 

        kml.save(os.path.join(approot,KMLfile))
    return statsfile, imglist, filelist
    #for sat in us_sarsats:
    #    dfsat = sat_find(dfout1,str(sat))
    #    dfout = dfsat
    #    statsout, mean, median, q95, win_5km, win_10km = stats(dfout,dist,q)
    #    rw = [sat]
    #    rw.extend(statsout)
    #    with open('out_sat_stats_sum.csv', 'a') as csvfile:
    #        csvwriter = csv.writer(csvfile, delimiter=',')
    #        csvwriter.writerow(rw)










     
    